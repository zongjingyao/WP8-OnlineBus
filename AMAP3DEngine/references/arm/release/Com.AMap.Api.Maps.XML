<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Com.AMap.Api.Maps</name>
  </assembly>
  <members>
    <member name="T:Com.AMap.Api.Maps.AMapGeolocator">
      <summary>
            适用于高德地图的定位接口 封装了 Geolocator 
            </summary>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMapGeolocator.GetGeopositionAsync">
      <summary>
            Initializes an asynchronous operation to retrieve the location of the user's
                computer.
            </summary>
      <returns> Provides methods for starting the asynchronous request for location data  and handling its completion.</returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMapGeolocator.GetGeopositionAsync(System.TimeSpan,System.TimeSpan)">
      <summary>
            Initializes an asynchronous operation to retrieve the location of the user's  computer.
            </summary>
      <param name="maximumAge">
      </param>
      <param name="timeout">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMapGeolocator.#ctor">
      <summary>
            封装了 Geolocator 
            </summary>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMapGeolocator.Start">
      <summary>
            定位开启
            </summary>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMapGeolocator.Stop">
      <summary>
            定位关闭
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMapGeolocator.DesiredAccuracy">
      <summary>
            The accuracy level at which the Geolocator provides location updates.
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMapGeolocator.LocationStatus">
      <summary>
            The status that indicates the ability of the Geolocator to provide location  updates.
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMapGeolocator.MovementThreshold">
      <summary>
            Gets the distance of movement, in meters, relative to the coordinate from
                the last PositionChanged event, that is required for the Geolocator to raise
                a PositionChanged event.
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMapGeolocator.ReportInterval">
      <summary>
                The requested minimum time interval between location updates, in milliseconds.
                If your application requires updates infrequently, set this value so that
                the location provider can conserve power by calculating location only when
                needed.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="E:Com.AMap.Api.Maps.AMapGeolocator.PositionChanged">
      <summary>
            Raised when the location is updated.
            </summary>
    </member>
    <member name="E:Com.AMap.Api.Maps.AMapGeolocator.StatusChanged">
      <summary>
            Raised when the ability of the Geolocator to provide updated location changes.
            </summary>
    </member>
    <member name="F:Com.AMap.Api.Maps.AMapLayer.LatLngProperty">
      <summary>
            标识LngLat附加属性，该属性表示给定元素的经纬度坐标。
            </summary>
    </member>
    <member name="F:Com.AMap.Api.Maps.AMapLayer.AnchorProperty">
      <summary>
            标识Anchor附加属性，该属性表示给定元素的锚点位置。
            </summary>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMapLayer.SetParent(System.Windows.UIElement,System.Object)">
      <summary>
            设置给定对象的Parent的附加属性值。
            </summary>
      <param name="element">向其中写入属性值的对象。</param>
      <param name="value">Parent属性值。</param>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMapLayer.GetParent(System.Windows.UIElement)">
      <summary>
            获取给定对象的Parent附加属性的值。
            </summary>
      <param name="element">从中读取属性值的对象。</param>
      <returns>指定对象的Parent值。</returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMapLayer.SetLngLat(System.Windows.UIElement,Com.AMap.Api.Maps.Model.LatLng)">
      <summary>
            设置给定对象的LngLat附加属性的值。
            </summary>
      <param name="element">向其中写入属性值的对象。</param>
      <param name="value">LngLat属性值。</param>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMapLayer.GetLngLat(System.Windows.UIElement)">
      <summary>
            获取给定对象的LngLat附加属性的值。
            </summary>
      <param name="element">从中读取属性值的对象。</param>
      <returns>指定对象的LngLat值。</returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMapLayer.SetAnchor(System.Windows.UIElement,System.Windows.Point)">
      <summary>
            设置指定对象的Anchor附加属性的值。
            </summary>
      <param name="element">向其中写入属性值的对象。</param>
      <param name="value">Anchor属性值。</param>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMapLayer.GetAnchor(System.Windows.UIElement)">
      <summary>
            获取给定对象的Anchor附加属性的值。
            </summary>
      <param name="element">从中读取属性值的对象。</param>
      <returns>指定对象的Anchor值。</returns>
    </member>
    <member name="T:Com.AMap.Api.Maps.AMapPositionChangedEventArgs">
      <summary>
            封装的 win8 定位接口 主要返回 适合高德地图使用的位置点
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMapPositionChangedEventArgs.PositionChangedEventArgs">
      <summary>
            wp8 自身返回的定位参数
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMapPositionChangedEventArgs.LngLat">
      <summary>
            适合高德地图的位置点
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMapPositionChangedEventArgs.Accuracy">
      <summary>
            定位后准确度 单位米
            </summary>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMapUtils.CalculateLineDistance(Com.AMap.Api.Maps.Model.LatLng,Com.AMap.Api.Maps.Model.LatLng)">
      <summary>
            计算路线距离
            </summary>
      <param name="startLatlng">
      </param>
      <param name="endLatlng">
      </param>
      <returns>
      </returns>
    </member>
    <member name="F:Com.AMap.Api.Maps.CameraUpdate.isAerialShowLayer">
      <summary>
            是否显示 卫星 实施交通图层
            </summary>
    </member>
    <member name="M:Com.AMap.Api.Maps.Model.AMapCircle.IsContains(Com.AMap.Api.Maps.Model.LatLng)">
      <summary>
            点在是否在圆内
            </summary>
      <param name="point">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.Model.AMapPolygon.IsContains(Com.AMap.Api.Maps.Model.LatLng)">
      <summary>
            点是否在多边形内
            </summary>
      <param name="point">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.Model.LatLngBounds.Contains(Com.AMap.Api.Maps.Model.LatLng)">
      <summary>
            判断矩形区域是否包含传入的经纬度点
            </summary>
      <param name="point">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.Model.LatLngBounds.Including(Com.AMap.Api.Maps.Model.LatLng)">
      <summary>
             返回一个新的矩形区域。新区域是根据传入的经纬度对原有区域进行最小的扩展。这个方法将选择向东北方向或西南方向扩展当中扩展面积相对较小一个区域。
            如果相同，则优先向西南方向扩展。
             </summary>
      <param name="point">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.Com.AMap.Api.Maps.Model.VisibleRegion.Equals(System.Object)">
      <summary>
            重写Equals
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.Com.AMap.Api.Maps.Model.VisibleRegion.ToString">
      <summary>
            重写ToString
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Com.AMap.Maps.Core.Unit">
      <summary>
            标准单位
            </summary>
    </member>
    <member name="F:Com.AMap.Maps.Core.Unit.Inch">
      <summary>
            英寸
            2.54 厘米
            </summary>
    </member>
    <member name="F:Com.AMap.Maps.Core.Unit.Mile">
      <summary>
            英里
            statute mile, 1,609.344 meters
            </summary>
    </member>
    <member name="F:Com.AMap.Maps.Core.Unit.Meter">
      <summary>
            米
            distance travelled by light in free space in 1/299,792,458 of a second ;)
            </summary>
    </member>
    <member name="F:Com.AMap.Maps.Core.Unit.Kilometer">
      <summary>
            千米 公里
            1000 meters
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.MMapControl">
      <summary>
            地图控件
            </summary>
    </member>
    <member name="F:Com.AMap.Maps.Core.MMapControl.Toolbar">
      <summary>
            工具条 
            </summary>
    </member>
    <member name="F:Com.AMap.Maps.Core.MMapControl.Scale">
      <summary>
            比例尺
            </summary>
    </member>
    <member name="F:Com.AMap.Maps.Core.MMapControl.Logo">
      <summary>
            logo
            </summary>
    </member>
    <member name="F:Com.AMap.Maps.Core.MMapControl.Copyright">
      <summary>
            版权信息
            </summary>
    </member>
    <member name="F:Com.AMap.Maps.Core.MMapControl.CenterCross">
      <summary>
            中心十字
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.MPosition">
      <summary>
            控件显示的位置
             </summary>
    </member>
    <member name="F:Com.AMap.Maps.Core.MPosition.TopLeft">
      <summary>
            左上
            </summary>
    </member>
    <member name="F:Com.AMap.Maps.Core.MPosition.TopRight">
      <summary>
            右上
            </summary>
    </member>
    <member name="F:Com.AMap.Maps.Core.MPosition.BottomRight">
      <summary>
            右下 
             </summary>
    </member>
    <member name="F:Com.AMap.Maps.Core.MPosition.BottomLeft">
      <summary>
            左下
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.TipLayer.MapInstance">
      <summary>
            所属地图
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.UIControls.CompassControl">
      <summary>
            指南针
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.UIControls.ForegroundControl">
      <summary>
            前景控件基类
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.UIControls.ForegroundControl.Position">
      <summary>
            控件所在位置
             </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.UIControls.ForegroundControl.MapControlType">
      <summary>
            控件类型
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.UIControls.ForegroundControl.Offset">
      <summary>
            控件偏移量
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.UIControls.ForegroundControl.IsActive">
      <summary>
            是否激活控件
            </summary>
    </member>
    <member name="M:Com.AMap.Api.Maps.Model.AMapMarker.ShowInfoWindow(System.Windows.FrameworkElement)">
      <summary>
            显示当前marker 的信息窗口。
            </summary>
    </member>
    <member name="M:Com.AMap.Api.Maps.Model.AMapMarker.HideInfoWindow">
      <summary>
            隐藏marker 的信息窗口。如果marker 本身是不可以见的，此方法将不起任何作用。
            </summary>
    </member>
    <member name="M:Com.AMap.Api.Maps.Model.AMapMarker.IsInfoWindowShown">
      <summary>
            如果marker 的信息窗口显示，返回true，否则返回false。此方法返回值时不会参考这个信息窗口是否在当前屏幕上真的可见。
            </summary>
      <returns>返回marker 是否可见。</returns>
    </member>
    <member name="P:Com.AMap.Api.Maps.Model.AMapMarker.Snippet">
      <summary>
      </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.Model.AMapMarker.Visible">
      <summary>
            设置获取marker 的可见属性。如果当前marker 的信息窗口处理显示状态，设置marker 的可见属性为false  时，信息窗口也会同时为不可见。
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.Model.AMapMarker.RWidth">
      <summary>
            真实宽度
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.Model.AMapMarker.RHeight">
      <summary>
            真实高度
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.Model.AMapMarker.RotateAngle">
      <summary>
            旋转角度
            </summary>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.#ctor">
      <summary>
            地图初始化事件
            </summary>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.DeleteAllCache">
      <summary>
            删除所有地图缓存,不建议在地图使用中调用该方法
            </summary>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.AddAMapLayer(Com.AMap.Api.Maps.AMapLayer)">
      <summary>
            添加地图图层
            </summary>
      <param name="layer">
      </param>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.RemoveAMapLayer(Com.AMap.Api.Maps.AMapLayer)">
      <summary>
            移除指定的地图图层
            </summary>
      <param name="layer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.MoveCamera(Com.AMap.Api.Maps.CameraUpdate)">
      <summary>
            根据CameraUpdate指定的方式（放大、缩小、平移等）重新设置地图视窗 
            </summary>
      <param name="update">
      </param>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.AddPolyline(Com.AMap.Api.Maps.Model.AMapPolylineOptions)">
      <summary>
            根据AMapPolylineOptions指定的折线参数添加一条折线到地图上 
            </summary>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.AddCircle(Com.AMap.Api.Maps.Model.AMapCircleOptions)">
      <summary>
            根据AMapCircleOptions指定的圆参数添加一个圆到地图上
            </summary>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.AddPolygon(Com.AMap.Api.Maps.Model.AMapPolygonOptions)">
      <summary>
            根据AMapPolygonOptions指定的多边形参数添加一个圆到地图上 
            </summary>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.AddMarker(Com.AMap.Api.Maps.Model.AMapMarkerOptions)">
      <summary>
            根据AMapMarkerOptions指定的标注参数添加一个标注到地图上。如果options参数为null，则该方法返回null
            </summary>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.GetMapMarkers">
      <summary>
            获取地图中所有的Marker对象
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.GetMapScreenMarkers">
      <summary>
            获取当前可视区域的所有Marker对象
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.Clear">
      <summary>
            删除所有的覆盖物,点、线、面、圆和图层（AMaplayer） 
             </summary>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.GetUiSettings">
      <summary>
            获取当前地图交互状态对象，包括是否可以旋转、平移、倾斜、放大等 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.GetProjection">
      <summary>
            获取AMapProjection对象，该对象用于做屏幕坐标和地图坐标之间的转换 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.IsInfoWindowShown">
      <summary>
            当前地图上有没有InfoWindow 显示 ，包括地图和marker的
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.HideInfoWindow">
      <summary>
            隐藏InfoWindow
            </summary>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.ShowInfoWindow(Com.AMap.Api.Maps.Model.LatLng,System.Windows.FrameworkElement)">
      <summary>
            指定位置显示 Tip容器
            </summary>
      <param name="center">经纬度</param>
      <param name="tip">Tip容器</param>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.ShowInfoWindow(Com.AMap.Api.Maps.Model.LatLng,System.Windows.FrameworkElement,System.Windows.Point)">
      <summary>
            指定位置显示 Tip容器
            </summary>
      <param name="center">经纬度</param>
      <param name="tip">Tip容器</param>
      <param name="anchor">锚点位置</param>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.map_MapLoaded(System.Object,System.Windows.RoutedEventArgs)">
      <summary>
            触发地图加载完成事件
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.GetScalePerPixel">
      <summary>
            获取屏幕每个像素对应的实际长度
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.map_RenderStart(System.Object,System.EventArgs)">
      <summary>
            每帧回调
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.AnimateCamera(Com.AMap.Api.Maps.CameraUpdate,System.Double)">
      <summary>
            动画移动
            </summary>
      <param name="update">
      </param>
      <param name="time">动画过渡时间</param>
    </member>
    <member name="M:Com.AMap.Api.Maps.AMap.StopAnimation">
      <summary>
            停止动画
            </summary>
    </member>
    <member name="E:Com.AMap.Api.Maps.AMap.Loaded">
      <summary>
            地图加载事件
            </summary>
    </member>
    <member name="E:Com.AMap.Api.Maps.AMap.CameraChangeListener">
      <summary>
            地图视窗(CameraPosition)发生变化后将会回调该函数
            </summary>
    </member>
    <member name="E:Com.AMap.Api.Maps.AMap.MarkerClickListener">
      <summary>
            点被点击的事件
            </summary>
    </member>
    <member name="E:Com.AMap.Api.Maps.AMap.MarkerDragLister">
      <summary>
            点被拖动的事件
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMap.Zoom">
      <summary>
            获取或者设置地图比例尺，比例尺值范围：4-20 
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMap.Bearing">
      <summary>
            获取或者设置地图旋转角度,以角度为单位，正北方向到地图方向逆时针旋转的角度，范围为：[0.f, 360.f] 
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMap.Tilt">
      <summary>
            获取或者设置地图倾角,范围为：范围为[0.f, 45.f] 
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMap.Center">
      <summary>
            获取或者设置地图中心点坐标 
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMap.MapType">
      <summary>
            获取或者设置地图类型，值为： Road或Aerial 
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMap.TrafficEnabled">
      <summary>
            获取或者设置实时交通信息图层是否显示 
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMap.APIVersion">
      <summary>
            AMap API的版本号
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMap.MaxZoomLevel">
      <summary>
            AMap 缩放最大级别
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.AMap.MinZoomLevel">
      <summary>
            AMap 缩放最小级别
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.Model.AMapMarkerOptions.IconUri">
      <summary>
            更改（获取）默认设置的 IconURL
            </summary>
      <remarks>
            可以是本地资源 也可以是远程图片 不能是GIF图
            </remarks>
    </member>
    <member name="P:Com.AMap.Api.Maps.Model.AMapMarkerOptions.Anchor">
      <summary>
            更改（获取）默认设置的 Anchor(锚点)  (0,0)-&gt;(1,1) 定义marker 图标的锚点。锚点是marker 图标接触地图平面的点。图标的左顶点为（0,0）点，右底点为（1,1）点。
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.Model.AMapMarkerOptions.IsDragable">
      <summary>
            是否可拖拽
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.Model.AMapMarkerOptions.RotateAngle">
      <summary>
            旋转角度
            </summary>
    </member>
    <member name="P:Com.AMap.Api.Maps.Model.AMapMarkerOptions.Periods">
      <summary>
            刷新周期，单位毫秒
            </summary>
    </member>
    <member name="M:Com.AMap.Maps.Core.AMapSurface.CompositionTarget_Rendering(System.Object,System.EventArgs)">
      <summary>
            刷新线程
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="M:Com.AMap.Maps.Core.AMapSurface.AMap_Tap(System.Object,System.Windows.Input.GestureEventArgs)">
      <summary>
            触摸事件
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="M:Com.AMap.Maps.Core.AMapSurface.AMap_Hold(System.Object,System.Windows.Input.GestureEventArgs)">
      <summary>
            长按事件
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="E:Com.AMap.Maps.Core.AMapSurface.MarkerClickListener">
      <summary>
            点被点击的事件
            </summary>
    </member>
    <member name="E:Com.AMap.Maps.Core.AMapSurface.MarkerDragLister">
      <summary>
            点被拖动的事件
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.AMapSurface.CompassControlEnabled">
      <summary>
            是否显示指南针
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.Input.GestureEventArgs">
      <summary>
            The base class for all gesture events. Also used by Tap, DoubleTap and Hold.
            </summary>
    </member>
    <member name="M:Com.AMap.Maps.Core.Input.GestureEventArgs.GetPosition(System.Windows.UIElement)">
      <summary>
            Returns the position of the gesture's starting point relative to a given UIElement.
            </summary>
      <param name="relativeTo">The return value will be relative to this element.</param>
      <returns>The gesture's starting point relative to the given UIElement.</returns>
    </member>
    <member name="M:Com.AMap.Maps.Core.Input.GestureEventArgs.GetPosition(System.Windows.UIElement,System.Windows.Point)">
      <summary>
            Returns the position of a given point relative to a given UIElement.
            </summary>
      <param name="relativeTo">The return value will be relative to this element.</param>
      <param name="point">The point to translate.</param>
      <returns>The given point relative to the given UIElement.</returns>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.GestureEventArgs.GestureOrigin">
      <summary>
            The point, in unrotated screen coordinates, where the gesture occurred.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.GestureEventArgs.TouchPosition">
      <summary>
            The point, in unrotated screen coordinates, where the first touchpoint is now.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.GestureEventArgs.OriginalSource">
      <summary>
            The first hit-testable item under the touch point. Determined by a combination of order in the tree and
            Z-order.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.GestureEventArgs.Handled">
      <summary>
            If an event handler sets this to true, it stops event bubbling.
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.Input.DragStartedGestureEventArgs">
      <summary>
            The event args used in the DragStarted event.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.DragStartedGestureEventArgs.Direction">
      <summary>
            The direction of the drag gesture, as determined by the initial drag change.
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.Input.DragDeltaGestureEventArgs">
      <summary>
            The event args used by the DragDelta event.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.DragDeltaGestureEventArgs.HorizontalChange">
      <summary>
            The horizontal (X) change for this drag event.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.DragDeltaGestureEventArgs.VerticalChange">
      <summary>
            The vertical (Y) change for this drag event.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.DragDeltaGestureEventArgs.Direction">
      <summary>
            The direction of the drag gesture, as determined by the initial drag change.
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.Input.DragCompletedGestureEventArgs">
      <summary>
            The event args used by the DragCompleted event.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.DragCompletedGestureEventArgs.HorizontalChange">
      <summary>
            The total horizontal (X) change of the drag event.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.DragCompletedGestureEventArgs.VerticalChange">
      <summary>
            The total vertical (Y) change of the drag event.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.DragCompletedGestureEventArgs.Direction">
      <summary>
            The direction of the drag gesture, as determined by the initial drag change.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.DragCompletedGestureEventArgs.HorizontalVelocity">
      <summary>
            The final horizontal (X) velocity of the drag, if the drag was inertial.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.DragCompletedGestureEventArgs.VerticalVelocity">
      <summary>
            The final vertical (Y) velocity of the drag, if the drag was inertial.
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.Input.FlickGestureEventArgs">
      <summary>
            The event args used by the Flick event.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.FlickGestureEventArgs.HorizontalVelocity">
      <summary>
            The horizontal (X) velocity of the flick.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.FlickGestureEventArgs.VerticalVelocity">
      <summary>
            The vertical (Y) velocity of the flick.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.FlickGestureEventArgs.Angle">
      <summary>
            The angle of the flick.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.FlickGestureEventArgs.Direction">
      <summary>
            The direction of the flick gesture, as determined by the flick velocities.
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.Input.MultiTouchGestureEventArgs">
      <summary>
            The base class for multi-touch gesture event args. Currently used only for
            two-finger (pinch) operations.
            </summary>
    </member>
    <member name="M:Com.AMap.Maps.Core.Input.MultiTouchGestureEventArgs.GetPosition(System.Windows.UIElement,System.Int32)">
      <summary>
            Returns the position of either of the two touch points (0 or 1) relative to
            the UIElement provided.
            </summary>
      <param name="relativeTo">The return value will be relative to this element.</param>
      <param name="index">The touchpoint to use (0 or 1).</param>
      <returns>The gesture's starting point relative to the given UIElement.</returns>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.MultiTouchGestureEventArgs.GestureOrigin2">
      <summary>
            The second touch point's initial position
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.MultiTouchGestureEventArgs.TouchPosition2">
      <summary>
            The second touch point. The first is stored in GestureEventArgs.
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.Input.PinchStartedGestureEventArgs">
      <summary>
            The event args used by the PinchStarted event.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.PinchStartedGestureEventArgs.Distance">
      <summary>
            The distance between the two touch points.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.PinchStartedGestureEventArgs.Angle">
      <summary>
            The angle defined by the two touch points.
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.Input.PinchGestureEventArgs">
      <summary>
            The event args used by the PinchDelta and PinchCompleted events.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.PinchGestureEventArgs.DistanceRatio">
      <summary>
            Returns the ratio of the current distance between touchpoints / the original distance
            between the touchpoints.
            </summary>
    </member>
    <member name="P:Com.AMap.Maps.Core.Input.PinchGestureEventArgs.TotalAngleDelta">
      <summary>
            Returns the difference in angle between the current touch positions and the original
            touch positions.
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.Input.GestureListener">
      <summary>
            The GestureListener class raises events similar to those provided by the XNA TouchPanel, but it is designed for
            XAML's event-driven model, rather than XNA's loop/polling model, and it also takes care of the hit testing
            and event routing.
            </summary>
    </member>
    <member name="M:Com.AMap.Maps.Core.Input.GestureListener.RaiseGestureEvent``1(System.Func{Com.AMap.Maps.Core.Input.GestureListener,System.EventHandler{``0}},System.Func{``0},System.Boolean)">
      <summary>
            This method does all the necessary work to raise a gesture event. It sets the orginal source, does the routing,
            handles Handled, and only creates the event args if they are needed.
            </summary>
      <typeparam name="T">This is the type of event args that will be raised.</typeparam>
      <param name="eventGetter">Gets the specific event to raise.</param>
      <param name="argsGetter">Lazy creator function for the event args.</param>
      <param name="releaseMouseCapture">Indicates whether the mouse capture should be released </param>
    </member>
    <member name="E:Com.AMap.Maps.Core.Input.GestureListener.GestureBegin">
      <summary>
            The GestureBegin event.
            </summary>
    </member>
    <member name="E:Com.AMap.Maps.Core.Input.GestureListener.GestureCompleted">
      <summary>
            The GestureCompleted event.
            </summary>
    </member>
    <member name="E:Com.AMap.Maps.Core.Input.GestureListener.Tap">
      <summary>
            The Tap event (touch, release, no movement).
            </summary>
    </member>
    <member name="E:Com.AMap.Maps.Core.Input.GestureListener.DoubleTap">
      <summary>
            The DoubleTap event is raised instead of Tap if the time between two taps is short eonugh.
            </summary>
    </member>
    <member name="E:Com.AMap.Maps.Core.Input.GestureListener.Hold">
      <summary>
            The Hold event (touch and hold for one second)
            </summary>
    </member>
    <member name="E:Com.AMap.Maps.Core.Input.GestureListener.DragStarted">
      <summary>
            The DragStarted event.
            </summary>
    </member>
    <member name="E:Com.AMap.Maps.Core.Input.GestureListener.DragDelta">
      <summary>
            The DragDelta event.
            </summary>
    </member>
    <member name="E:Com.AMap.Maps.Core.Input.GestureListener.DragCompleted">
      <summary>
            The DragCompleted event. Will be raised on touch release after a drag, or
            when a second touch point is added.
            </summary>
    </member>
    <member name="E:Com.AMap.Maps.Core.Input.GestureListener.Flick">
      <summary>
            The Flick event. Raised when a drag that was fast enough ends with a release.
            </summary>
    </member>
    <member name="E:Com.AMap.Maps.Core.Input.GestureListener.PinchStarted">
      <summary>
            The PinchStarted event.
            </summary>
    </member>
    <member name="E:Com.AMap.Maps.Core.Input.GestureListener.PinchDelta">
      <summary>
            Any two-touch point (two finger) operation.
            </summary>
    </member>
    <member name="E:Com.AMap.Maps.Core.Input.GestureListener.PinchCompleted">
      <summary>
            The end of a pinch operation.
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.Input.GestureService">
      <summary>
            The GestureService class is the helper for getting and setting GestureListeners
            on elements.
            </summary>
    </member>
    <member name="M:Com.AMap.Maps.Core.Input.GestureService.GetGestureListener(System.Windows.DependencyObject)">
      <summary>
            Gets a GestureListener for the new element. Will create a new one if necessary.
            </summary>
      <param name="obj">The object to get the GestureListener from.</param>
      <returns>Either the previously existing GestureListener, or a new one.</returns>
    </member>
    <member name="M:Com.AMap.Maps.Core.Input.GestureService.SetGestureListener(System.Windows.DependencyObject,Com.AMap.Maps.Core.Input.GestureListener)">
      <summary>
            Sets the GestureListener on an element. Needed for XAML, but should not be used in code. Use
            GetGestureListener instead, which will create a new instance if one is not already set, to 
            add your handlers to an element.
            </summary>
      <param name="obj">The object to set the GestureListener on.</param>
      <param name="value">The GestureListener.</param>
    </member>
    <member name="F:Com.AMap.Maps.Core.Input.GestureService.GestureListenerProperty">
      <summary>
            The definition of the GestureListener attached DependencyProperty.
            </summary>
    </member>
    <member name="T:Com.AMap.Maps.Core.UIControls.ScaleControl">
      <summary>
            比例尺
            </summary>
    </member>
    <member name="M:Com.AMap.Maps.Core.UIControls.ZoomBar.ZoomBar_Tap(System.Object,System.Windows.Input.GestureEventArgs)">
      <summary>
            禁止事件传递
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="M:AutoNavi.Amap3d.Common.BufferedBlockCipher.#ctor">
            constructor for subclasses
        </member>
    <member name="M:AutoNavi.Amap3d.Common.DESUtil.DESEncrpyt(System.String,System.Byte[])">
      <summary>
            des 加密
            </summary>
      <param name="strOrgin">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Com.AMap.Api.Maps.Com.AMap.Maps.Core.Utilities.DataEncryptCommon.KeySet">
      <summary>
            Declaration of KEY_SET class
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Checksums.Adler32">
      <summary>
            Computes Adler32 checksum for a stream of data. An Adler32
            checksum is not as reliable as a CRC32 checksum, but a lot faster to
            compute.
            
            The specification for Adler32 may be found in RFC 1950.
            ZLIB Compressed Data Format Specification version 3.3)
            
            
            From that document:
            
                 "ADLER32 (Adler-32 checksum)
                  This contains a checksum value of the uncompressed data
                  (excluding any dictionary data) computed according to Adler-32
                  algorithm. This algorithm is a 32-bit extension and improvement
                  of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073
                  standard.
            
                  Adler-32 is composed of two sums accumulated per byte: s1 is
                  the sum of all bytes, s2 is the sum of all s1 values. Both sums
                  are done modulo 65521. s1 is initialized to 1, s2 to zero.  The
                  Adler-32 checksum is stored as s2*65536 + s1 in most-
                  significant-byte first (network) order."
            
             "8.2. The Adler-32 algorithm
            
               The Adler-32 algorithm is much faster than the CRC32 algorithm yet
               still provides an extremely low probability of undetected errors.
            
               The modulo on unsigned long accumulators can be delayed for 5552
               bytes, so the modulo operation time is negligible.  If the bytes
               are a, b, c, the second sum is 3a + 2b + c + 3, and so is position
               and order sensitive, unlike the first sum, which is just a
               checksum.  That 65521 is prime is important to avoid a possible
               large class of two-byte errors that leave the check unchanged.
               (The Fletcher checksum uses 255, which is not prime and which also
               makes the Fletcher check insensitive to single byte changes 0 -
               255.)
            
               The sum s1 is initialized to 1 instead of zero to make the length
               of the sequence part of s2, so that the length does not have to be
               checked separately. (Any sequence of zeroes has a Fletcher
               checksum of zero.)"
            </summary>
      <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream" />
      <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream" />
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Checksums.IChecksum">
      <summary>
            Interface to compute a data checksum used by checked input/output streams.
            A data checksum can be updated by one byte or with a byte array. After each
            update the value of the current checksum can be returned by calling
            <code>getValue</code>. The complete checksum object can also be reset
            so it can be used again with new data.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.IChecksum.Reset">
      <summary>
            Resets the data checksum as if no update was ever called.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.IChecksum.Update(System.Int32)">
      <summary>
            Adds one byte to the data checksum.
            </summary>
      <param name="value">
            the data value to add. The high byte of the int is ignored.
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.IChecksum.Update(System.Byte[])">
      <summary>
            Updates the data checksum with the bytes taken from the array.
            </summary>
      <param name="buffer">
            buffer an array of bytes
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.IChecksum.Update(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Adds the byte array to the data checksum.
            </summary>
      <param name="buffer">
            The buffer which contains the data
            </param>
      <param name="offset">
            The offset in the buffer where the data starts
            </param>
      <param name="count">
            the number of data bytes to add.
            </param>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Checksums.IChecksum.Value">
      <summary>
            Returns the data checksum computed so far.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Checksums.Adler32.BASE">
      <summary>
            largest prime smaller than 65536
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.#ctor">
      <summary>
            Creates a new instance of the Adler32 class.
            The checksum starts off with a value of 1.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.Reset">
      <summary>
            Resets the Adler32 checksum to the initial value.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.Update(System.Int32)">
      <summary>
            Updates the checksum with a byte value.
            </summary>
      <param name="value">
            The data value to add. The high byte of the int is ignored.
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.Update(System.Byte[])">
      <summary>
            Updates the checksum with an array of bytes.
            </summary>
      <param name="buffer">
            The source of the data to update with.
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.Update(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
      <param name="buffer">
            an array of bytes
            </param>
      <param name="offset">
            the start of the data used for this update
            </param>
      <param name="count">
            the number of bytes to use for this update
            </param>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Checksums.Adler32.Value">
      <summary>
            Returns the Adler32 data checksum computed so far.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Checksums.Crc32">
      <summary>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
            
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Crc32.Reset">
      <summary>
            Resets the CRC32 data checksum as if no update was ever called.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Crc32.Update(System.Int32)">
      <summary>
            Updates the checksum with the int bval.
            </summary>
      <param name="value">
            the byte is taken as the lower 8 bits of value
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Crc32.Update(System.Byte[])">
      <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
      <param name="buffer">
            buffer an array of bytes
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Adds the byte array to the data checksum.
            </summary>
      <param name="buffer">
            The buffer which contains the data
            </param>
      <param name="offset">
            The offset in the buffer where the data starts
            </param>
      <param name="count">
            The number of data bytes to update the CRC with.
            </param>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Checksums.Crc32.Value">
      <summary>
            Returns the CRC32 data checksum computed so far.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Checksums.StrangeCRC">
      <summary>
            Bzip2 checksum algorithm
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.#ctor">
      <summary>
            Initialise a default instance of <see cref="T:ICSharpCode.SharpZipLib.Checksums.StrangeCRC"></see></summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Reset">
      <summary>
            Reset the state of Crc.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Update(System.Int32)">
      <summary>
            Update the Crc value.
            </summary>
      <param name="value">data update is based on</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Update(System.Byte[])">
      <summary>
            Update Crc based on a block of data
            </summary>
      <param name="buffer">The buffer containing data to update the crc with.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Update(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Update Crc based on a portion of a block of data
            </summary>
      <param name="buffer">block of data</param>
      <param name="offset">index of first byte to use</param>
      <param name="count">number of bytes to use</param>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Value">
      <summary>
            Get the current Crc value.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.ScanEventArgs">
      <summary>
            Event arguments for scanning.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.ScanEventArgs.#ctor(System.String)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.ScanEventArgs" /></summary>
      <param name="name">The file or directory name.</param>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ScanEventArgs.Name">
      <summary>
            The file or directory name for this event.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ScanEventArgs.ContinueRunning">
      <summary>
            Get set a value indicating if scanning should continue or not.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.ProgressEventArgs">
      <summary>
            Event arguments during processing of a single file or directory.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.ProgressEventArgs.#ctor(System.String,System.Int64,System.Int64)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.ScanEventArgs" /></summary>
      <param name="name">The file or directory name if known.</param>
      <param name="processed">The number of bytes processed so far</param>
      <param name="target">The total number of bytes to process, 0 if not known</param>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ProgressEventArgs.Name">
      <summary>
            The name for this event if known.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ProgressEventArgs.ContinueRunning">
      <summary>
            Get set a value indicating wether scanning should continue or not.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ProgressEventArgs.PercentComplete">
      <summary>
            Get a percentage representing how much of the <see cref="P:ICSharpCode.SharpZipLib.Core.ProgressEventArgs.Target"></see> has been processed
            </summary>
      <value>0.0 to 100.0 percent; 0 if target is not known.</value>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ProgressEventArgs.Processed">
      <summary>
            The number of bytes processed so far
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ProgressEventArgs.Target">
      <summary>
            The number of bytes to process.
            </summary>
      <remarks>Target may be 0 or negative if the value isnt known.</remarks>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.DirectoryEventArgs">
      <summary>
            Event arguments for directories.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.DirectoryEventArgs.#ctor(System.String,System.Boolean)">
      <summary>
            Initialize an instance of <see cref="T:ICSharpCode.SharpZipLib.Core.DirectoryEventArgs"></see>.
            </summary>
      <param name="name">The name for this directory.</param>
      <param name="hasMatchingFiles">Flag value indicating if any matching files are contained in this directory.</param>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.DirectoryEventArgs.HasMatchingFiles">
      <summary>
            Get a value indicating if the directory contains any matching files or not.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs">
      <summary>
            Arguments passed when scan failures are detected.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs.#ctor(System.String,System.Exception)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs"></see></summary>
      <param name="name">The name to apply.</param>
      <param name="e">The exception to use.</param>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs.Name">
      <summary>
            The applicable name.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs.Exception">
      <summary>
            The applicable exception.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs.ContinueRunning">
      <summary>
            Get / set a value indicating wether scanning should continue.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.ProcessDirectoryHandler">
      <summary>
            Delegate invoked before starting to process a directory.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.ProcessFileHandler">
      <summary>
            Delegate invoked before starting to process a file.
            </summary>
      <param name="sender">The source of the event</param>
      <param name="e">The event arguments.</param>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.ProgressHandler">
      <summary>
            Delegate invoked during processing of a file or directory
            </summary>
      <param name="sender">The source of the event</param>
      <param name="e">The event arguments.</param>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.CompletedFileHandler">
      <summary>
            Delegate invoked when a file has been completely processed.
            </summary>
      <param name="sender">The source of the event</param>
      <param name="e">The event arguments.</param>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.DirectoryFailureHandler">
      <summary>
            Delegate invoked when a directory failure is detected.
            </summary>
      <param name="sender">The source of the event</param>
      <param name="e">The event arguments.</param>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.FileFailureHandler">
      <summary>
            Delegate invoked when a file failure is detected.
            </summary>
      <param name="sender">The source of the event</param>
      <param name="e">The event arguments.</param>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.FileSystemScanner">
      <summary>
            FileSystemScanner provides facilities scanning of files and directories.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.#ctor(System.String)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.FileSystemScanner"></see></summary>
      <param name="filter">The <see cref="T:ICSharpCode.SharpZipLib.Core.PathFilter">file filter</see> to apply when scanning.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.#ctor(System.String,System.String)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.FileSystemScanner"></see></summary>
      <param name="fileFilter">The <see cref="T:ICSharpCode.SharpZipLib.Core.PathFilter">file filter</see> to apply.</param>
      <param name="directoryFilter">The <see cref="T:ICSharpCode.SharpZipLib.Core.PathFilter"> directory filter</see> to apply.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.#ctor(ICSharpCode.SharpZipLib.Core.IScanFilter)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.FileSystemScanner"></see></summary>
      <param name="fileFilter">The file <see cref="T:ICSharpCode.SharpZipLib.Core.IScanFilter">filter</see> to apply.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.#ctor(ICSharpCode.SharpZipLib.Core.IScanFilter,ICSharpCode.SharpZipLib.Core.IScanFilter)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.FileSystemScanner"></see></summary>
      <param name="fileFilter">The file <see cref="T:ICSharpCode.SharpZipLib.Core.IScanFilter">filter</see>  to apply.</param>
      <param name="directoryFilter">The directory <see cref="T:ICSharpCode.SharpZipLib.Core.IScanFilter">filter</see>  to apply.</param>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Core.FileSystemScanner.ProcessDirectory">
      <summary>
            Delegate to invoke when a directory is processed.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Core.FileSystemScanner.ProcessFile">
      <summary>
            Delegate to invoke when a file is processed.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Core.FileSystemScanner.CompletedFile">
      <summary>
            Delegate to invoke when processing for a file has finished.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Core.FileSystemScanner.DirectoryFailure">
      <summary>
            Delegate to invoke when a directory failure is detected.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Core.FileSystemScanner.FileFailure">
      <summary>
            Delegate to invoke when a file failure is detected.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.OnCompleteFile(System.String)">
      <summary>
            Raise the complete file event
            </summary>
      <param name="file">The file name</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.Scan(System.String,System.Boolean)">
      <summary>
            Scan a directory.
            </summary>
      <param name="directory">The base directory to scan.</param>
      <param name="recurse">True to recurse subdirectories, false to scan a single directory.</param>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.INameTransform">
      <summary>
            INameTransform defines how file system names are transformed for use with archives, or vice versa.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.INameTransform.TransformFile(System.String)">
      <summary>
            Given a file name determine the transformed value.
            </summary>
      <param name="name">The name to transform.</param>
      <returns>The transformed file name.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.INameTransform.TransformDirectory(System.String)">
      <summary>
            Given a directory name determine the transformed value.
            </summary>
      <param name="name">The name to transform.</param>
      <returns>The transformed directory name</returns>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.IScanFilter">
      <summary>
            Scanning filters support filtering of names.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.IScanFilter.IsMatch(System.String)">
      <summary>
            Test a name to see if it 'matches' the filter.
            </summary>
      <param name="name">The name to test.</param>
      <returns>Returns true if the name matches the filter, false if it does not match.</returns>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.NameFilter">
      <summary>
            NameFilter is a string matching class which allows for both positive and negative
            matching.
            A filter is a sequence of independant <see cref="T:System.Text.RegularExpressions.Regex">regular expressions</see> separated by semi-colons ';'.
            To include a semi-colon it may be quoted as in \;. Each expression can be prefixed by a plus '+' sign or
            a minus '-' sign to denote the expression is intended to include or exclude names.
            If neither a plus or minus sign is found include is the default.
            A given name is tested for inclusion before checking exclusions.  Only names matching an include spec 
            and not matching an exclude spec are deemed to match the filter.
            An empty filter matches any name.
            </summary>
      <example>The following expression includes all name ending in '.dat' with the exception of 'dummy.dat'
            "+\.dat$;-^dummy\.dat$"
            </example>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.#ctor(System.String)">
      <summary>
            Construct an instance based on the filter expression passed
            </summary>
      <param name="filter">The filter expression.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsValidExpression(System.String)">
      <summary>
            Test a string to see if it is a valid regular expression.
            </summary>
      <param name="expression">The expression to test.</param>
      <returns>True if expression is a valid <see cref="T:System.Text.RegularExpressions.Regex" /> false otherwise.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsValidFilterExpression(System.String)">
      <summary>
            Test an expression to see if it is valid as a filter.
            </summary>
      <param name="toTest">The filter expression to test.</param>
      <returns>True if the expression is valid, false otherwise.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.SplitQuoted(System.String)">
      <summary>
            Split a string into its component pieces
            </summary>
      <param name="original">The original string</param>
      <returns>Returns an array of <see cref="T:System.String" /> values containing the individual filter elements.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.ToString">
      <summary>
            Convert this filter to its string equivalent.
            </summary>
      <returns>The string equivalent for this filter.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsIncluded(System.String)">
      <summary>
            Test a value to see if it is included by the filter.
            </summary>
      <param name="name">The value to test.</param>
      <returns>True if the value is included, false otherwise.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsExcluded(System.String)">
      <summary>
            Test a value to see if it is excluded by the filter.
            </summary>
      <param name="name">The value to test.</param>
      <returns>True if the value is excluded, false otherwise.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsMatch(System.String)">
      <summary>
            Test a value to see if it matches the filter.
            </summary>
      <param name="name">The value to test.</param>
      <returns>True if the value matches, false otherwise.</returns>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.PathFilter">
      <summary>
            PathFilter filters directories and files using a form of <see cref="T:System.Text.RegularExpressions.Regex">regular expressions</see>
            by full path name.
            See <see cref="T:ICSharpCode.SharpZipLib.Core.NameFilter">NameFilter</see> for more detail on filtering.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.PathFilter.#ctor(System.String)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.PathFilter"></see>.
            </summary>
      <param name="filter">The <see cref="T:ICSharpCode.SharpZipLib.Core.NameFilter">filter</see> expression to apply.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.PathFilter.IsMatch(System.String)">
      <summary>
            Test a name to see if it matches the filter.
            </summary>
      <param name="name">The name to test.</param>
      <returns>True if the name matches, false otherwise.</returns>
      <remarks>
        <see cref="M:System.IO.Path.GetFullPath(System.String)" /> is used to get the full path before matching.</remarks>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter">
      <summary>
            ExtendedPathFilter filters based on name, file size, and the last write time of the file.
            </summary>
      <remarks>Provides an example of how to customise filtering.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.#ctor(System.String,System.Int64,System.Int64)">
      <summary>
            Initialise a new instance of ExtendedPathFilter.
            </summary>
      <param name="filter">The filter to apply.</param>
      <param name="minSize">The minimum file size to include.</param>
      <param name="maxSize">The maximum file size to include.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.#ctor(System.String,System.DateTime,System.DateTime)">
      <summary>
            Initialise a new instance of ExtendedPathFilter.
            </summary>
      <param name="filter">The filter to apply.</param>
      <param name="minDate">The minimum <see cref="T:System.DateTime" /> to include.</param>
      <param name="maxDate">The maximum <see cref="T:System.DateTime" /> to include.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.#ctor(System.String,System.Int64,System.Int64,System.DateTime,System.DateTime)">
      <summary>
            Initialise a new instance of ExtendedPathFilter.
            </summary>
      <param name="filter">The filter to apply.</param>
      <param name="minSize">The minimum file size to include.</param>
      <param name="maxSize">The maximum file size to include.</param>
      <param name="minDate">The minimum <see cref="T:System.DateTime" /> to include.</param>
      <param name="maxDate">The maximum <see cref="T:System.DateTime" /> to include.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.IsMatch(System.String)">
      <summary>
            Test a filename to see if it matches the filter.
            </summary>
      <param name="name">The filename to test.</param>
      <returns>True if the filter matches, false otherwise.</returns>
      <exception cref="T:System.IO.FileNotFoundException">The <see paramref="fileName" /> doesnt exist</exception>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MinSize">
      <summary>
            Get/set the minimum size/length for a file that will match this filter.
            </summary>
      <remarks>The default value is zero.</remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">value is less than zero; greater than <see cref="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MaxSize" /></exception>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MaxSize">
      <summary>
            Get/set the maximum size/length for a file that will match this filter.
            </summary>
      <remarks>The default value is <see cref="F:System.Int64.MaxValue" /></remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">value is less than zero or less than <see cref="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MinSize" /></exception>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MinDate">
      <summary>
            Get/set the minimum <see cref="T:System.DateTime" /> value that will match for this filter.
            </summary>
      <remarks>Files with a LastWrite time less than this value are excluded by the filter.</remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MaxDate">
      <summary>
            Get/set the maximum <see cref="T:System.DateTime" /> value that will match for this filter.
            </summary>
      <remarks>Files with a LastWrite time greater than this value are excluded by the filter.</remarks>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter">
      <summary>
            NameAndSizeFilter filters based on name and file size.
            </summary>
      <remarks>A sample showing how filters might be extended.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter.#ctor(System.String,System.Int64,System.Int64)">
      <summary>
            Initialise a new instance of NameAndSizeFilter.
            </summary>
      <param name="filter">The filter to apply.</param>
      <param name="minSize">The minimum file size to include.</param>
      <param name="maxSize">The maximum file size to include.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter.IsMatch(System.String)">
      <summary>
            Test a filename to see if it matches the filter.
            </summary>
      <param name="name">The filename to test.</param>
      <returns>True if the filter matches, false otherwise.</returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter.MinSize">
      <summary>
            Get/set the minimum size for a file that will match this filter.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter.MaxSize">
      <summary>
            Get/set the maximum size for a file that will match this filter.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.StreamUtils">
      <summary>
            Provides simple <see cref="T:System.IO.Stream" />" utilities.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.StreamUtils.ReadFully(System.IO.Stream,System.Byte[])">
      <summary>
            Read from a <see cref="T:System.IO.Stream" /> ensuring all the required data is read.
            </summary>
      <param name="stream">The stream to read.</param>
      <param name="buffer">The buffer to fill.</param>
      <seealso cref="M:ICSharpCode.SharpZipLib.Core.StreamUtils.ReadFully(System.IO.Stream,System.Byte[],System.Int32,System.Int32)" />
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.StreamUtils.ReadFully(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
      <summary>
            Read from a <see cref="T:System.IO.Stream" />" ensuring all the required data is read.
            </summary>
      <param name="stream">The stream to read data from.</param>
      <param name="buffer">The buffer to store data in.</param>
      <param name="offset">The offset at which to begin storing data.</param>
      <param name="count">The number of bytes of data to store.</param>
      <exception cref="T:System.ArgumentNullException">Required parameter is null</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> and or <paramref name="count" /> are invalid.</exception>
      <exception cref="T:System.IO.EndOfStreamException">End of stream is encountered before all the data has been read.</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.StreamUtils.Copy(System.IO.Stream,System.IO.Stream,System.Byte[])">
      <summary>
            Copy the contents of one <see cref="T:System.IO.Stream" /> to another.
            </summary>
      <param name="source">The stream to source data from.</param>
      <param name="destination">The stream to write data to.</param>
      <param name="buffer">The buffer to use during copying.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.StreamUtils.Copy(System.IO.Stream,System.IO.Stream,System.Byte[],ICSharpCode.SharpZipLib.Core.ProgressHandler,System.TimeSpan,System.Object,System.String)">
      <summary>
            Copy the contents of one <see cref="T:System.IO.Stream" /> to another.
            </summary>
      <param name="source">The stream to source data from.</param>
      <param name="destination">The stream to write data to.</param>
      <param name="buffer">The buffer to use during copying.</param>
      <param name="progressHandler">The <see cref="T:ICSharpCode.SharpZipLib.Core.ProgressHandler">progress handler delegate</see> to use.</param>
      <param name="updateInterval">The minimum <see cref="T:System.TimeSpan" /> between progress updates.</param>
      <param name="sender">The source for this event.</param>
      <param name="name">The name to use with the event.</param>
      <remarks>This form is specialised for use within #Zip to support events during archive operations.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.StreamUtils.Copy(System.IO.Stream,System.IO.Stream,System.Byte[],ICSharpCode.SharpZipLib.Core.ProgressHandler,System.TimeSpan,System.Object,System.String,System.Int64)">
      <summary>
            Copy the contents of one <see cref="T:System.IO.Stream" /> to another.
            </summary>
      <param name="source">The stream to source data from.</param>
      <param name="destination">The stream to write data to.</param>
      <param name="buffer">The buffer to use during copying.</param>
      <param name="progressHandler">The <see cref="T:ICSharpCode.SharpZipLib.Core.ProgressHandler">progress handler delegate</see> to use.</param>
      <param name="updateInterval">The minimum <see cref="T:System.TimeSpan" /> between progress updates.</param>
      <param name="sender">The source for this event.</param>
      <param name="name">The name to use with the event.</param>
      <param name="fixedTarget">A predetermined fixed target value to use with progress updates.
            If the value is negative the target is calculated by looking at the stream.</param>
      <remarks>This form is specialised for use within #Zip to support events during archive operations.</remarks>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Core.WindowsPathUtils">
      <summary>
            WindowsPathUtils provides simple utilities for handling windows paths.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Core.WindowsPathUtils.DropPathRoot(System.String)">
      <summary>
            Remove any path root present in the path
            </summary>
      <param name="path">A <see cref="T:System.String" /> containing path information.</param>
      <returns>The path with the root removed if it was present; path otherwise.</returns>
      <remarks>Unlike the <see cref="T:System.IO.Path" /> class the path isnt otherwise checked for validity.</remarks>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassic">
      <summary>
            PkzipClassic embodies the classic or original encryption facilities used in Pkzip archives.
            While it has been superceded by more recent and more powerful algorithms, its still in use and 
            is viable for preventing casual snooping
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassic.GenerateKeys(System.Byte[])">
      <summary>
            Generates new encryption keys based on given seed
            </summary>
      <param name="seed">The seed value to initialise keys with.</param>
      <returns>A new key value.</returns>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged">
      <summary>
            Defines a wrapper object to access the Pkzip algorithm. 
            This class cannot be inherited.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.GenerateIV">
      <summary>
            Generate an initial vector.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.GenerateKey">
      <summary>
            Generate a new random key.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.CreateEncryptor(System.Byte[],System.Byte[])">
      <summary>
            Create an encryptor.
            </summary>
      <param name="rgbKey">The key to use for this encryptor.</param>
      <param name="rgbIV">Initialisation vector for the new encryptor.</param>
      <returns>Returns a new PkzipClassic encryptor</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.CreateDecryptor(System.Byte[],System.Byte[])">
      <summary>
            Create a decryptor.
            </summary>
      <param name="rgbKey">Keys to use for this new decryptor.</param>
      <param name="rgbIV">Initialisation vector for the new decryptor.</param>
      <returns>Returns a new decryptor.</returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.BlockSize">
      <summary>
            Get / set the applicable block size in bits.
            </summary>
      <remarks>The only valid block size is 8.</remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.LegalKeySizes">
      <summary>
            Get an array of legal <see cref="T:System.Security.Cryptography.KeySizes">key sizes.</see></summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.LegalBlockSizes">
      <summary>
            Get an array of legal <see cref="T:System.Security.Cryptography.KeySizes">block sizes</see>.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.Key">
      <summary>
            Get / set the key value applicable.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.GZip.GZipConstants">
      <summary>
            This class contains constants used for gzip.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.GZip.GZipConstants.GZIP_MAGIC">
      <summary>
            Magic number found at start of GZIP header
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.GZip.GZipConstants.FTEXT">
      <summary>
            Flag bit mask for text
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.GZip.GZipConstants.FHCRC">
      <summary>
            Flag bitmask for Crc
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.GZip.GZipConstants.FEXTRA">
      <summary>
            Flag bit mask for extra
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.GZip.GZipConstants.FNAME">
      <summary>
            flag bitmask for name
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.GZip.GZipConstants.FCOMMENT">
      <summary>
            flag bit mask indicating comment is present
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.GZip.GZipException">
      <summary>
            GZipException represents a Gzip specific exception	
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
      <summary>
            SharpZipBaseException is the base exception class for the SharpZipLibrary.
            All library exceptions are derived from this.
            </summary>
      <remarks>NOTE: Not all exceptions thrown will be derived from this class.
            A variety of other exceptions are possible for example <see cref="T:System.ArgumentNullException"></see></remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.SharpZipBaseException.#ctor">
      <summary>
            Initializes a new instance of the SharpZipBaseException class.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.SharpZipBaseException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the SharpZipBaseException class with a specified error message.
            </summary>
      <param name="message">A message describing the exception.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.SharpZipBaseException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the SharpZipBaseException class with a specified
            error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">A message describing the exception.</param>
      <param name="innerException">The inner exception</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipException.#ctor">
      <summary>
            Initialise a new instance of GZipException
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipException.#ctor(System.String)">
      <summary>
            Initialise a new instance of GZipException with its message string.
            </summary>
      <param name="message">A <see cref="T:System.String" /> that describes the error.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipException.#ctor(System.String,System.Exception)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.GZip.GZipException"></see>.
            </summary>
      <param name="message">A <see cref="T:System.String" /> that describes the error.</param>
      <param name="innerException">The <see cref="T:System.Exception" /> that caused this exception.</param>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.GZip.GZipInputStream">
      <summary>
            This filter stream is used to decompress a "GZIP" format stream.
            The "GZIP" format is described baseInputStream RFC 1952.
            
            author of the original java version : John Leuner
            </summary>
      <example> This sample shows how to unzip a gzipped file
            <code>
            using System;
            using System.IO;
            
            using ICSharpCode.SharpZipLib.Core;
            using ICSharpCode.SharpZipLib.GZip;
            
            class MainClass
            {
            	public static void Main(string[] args)
            	{
            		using (Stream inStream = new GZipInputStream(File.OpenRead(args[0])))
            		using (FileStream outStream = File.Create(Path.GetFileNameWithoutExtension(args[0]))) {
            			byte[] buffer = new byte[4096];
            			StreamUtils.Copy(inStream, outStream, buffer);
            		}
            	}
            }	
            </code></example>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream">
      <summary>
             This filter stream is used to decompress data compressed using the "deflate"
             format. The "deflate" format is described in RFC 1951.
            
             This stream may form the basis for other decompression filters, such
             as the <see cref="T:ICSharpCode.SharpZipLib.GZip.GZipInputStream">GZipInputStream</see>.
            
             Author of the original java version : John Leuner.
             </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream)">
      <summary>
            Create an InflaterInputStream with the default decompressor
            and a default buffer size of 4KB.
            </summary>
      <param name="baseInputStream">
            The InputStream to read bytes from
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
      <summary>
            Create an InflaterInputStream with the specified decompressor
            and a default buffer size of 4KB.
            </summary>
      <param name="baseInputStream">
            The source of input data
            </param>
      <param name="inf">
            The decompressor used to decompress data read from baseInputStream
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Inflater,System.Int32)">
      <summary>
            Create an InflaterInputStream with the specified decompressor
            and the specified buffer size.
            </summary>
      <param name="baseInputStream">
            The InputStream to read bytes from
            </param>
      <param name="inflater">
            The decompressor to use
            </param>
      <param name="bufferSize">
            Size of the buffer to use
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Skip(System.Int64)">
      <summary>
            Skip specified number of bytes of uncompressed data
            </summary>
      <param name="count">
            Number of bytes to skip
            </param>
      <returns>
            The number of bytes skipped, zero if the end of 
            stream has been reached
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count">The number of bytes</paramref> to skip is less than or equal to zero.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.StopDecrypting">
      <summary>
            Clear any cryptographic state.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Fill">
      <summary>
            Fills the buffer with more data to decompress.
            </summary>
      <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            Stream ends early
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Flush">
      <summary>
            Flushes the baseInputStream
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
            Sets the position within the current stream
            Always throws a NotSupportedException
            </summary>
      <param name="offset">The relative offset to seek to.</param>
      <param name="origin">The <see cref="T:System.IO.SeekOrigin" /> defining where to seek from.</param>
      <returns>The new position in the stream.</returns>
      <exception cref="T:System.NotSupportedException">Any access</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.SetLength(System.Int64)">
      <summary>
            Set the length of the current stream
            Always throws a NotSupportedException
            </summary>
      <param name="value">The new length value for the stream.</param>
      <exception cref="T:System.NotSupportedException">Any access</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Writes a sequence of bytes to stream and advances the current position
            This method always throws a NotSupportedException
            </summary>
      <param name="buffer">Thew buffer containing data to write.</param>
      <param name="offset">The offset of the first byte to write.</param>
      <param name="count">The number of bytes to write.</param>
      <exception cref="T:System.NotSupportedException">Any access</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.WriteByte(System.Byte)">
      <summary>
            Writes one byte to the current stream and advances the current position
            Always throws a NotSupportedException
            </summary>
      <param name="value">The byte to write.</param>
      <exception cref="T:System.NotSupportedException">Any access</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <summary>
            Entry point to begin an asynchronous write.  Always throws a NotSupportedException.
            </summary>
      <param name="buffer">The buffer to write data from</param>
      <param name="offset">Offset of first byte to write</param>
      <param name="count">The maximum number of bytes to write</param>
      <param name="callback">The method to be called when the asynchronous write operation is completed</param>
      <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests</param>
      <returns>An <see cref="T:System.IAsyncResult">IAsyncResult</see> that references the asynchronous write</returns>
      <exception cref="T:System.NotSupportedException">Any access</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Close">
      <summary>
            Closes the input stream.  When <see cref="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner"></see>
            is true the underlying stream is also closed.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Reads decompressed data into the provided buffer byte array
            </summary>
      <param name="buffer">
            The array to read and decompress data into
            </param>
      <param name="offset">
            The offset indicating where the data should be placed
            </param>
      <param name="count">
            The number of bytes to decompress
            </param>
      <returns>The number of bytes read.  Zero signals the end of stream</returns>
      <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            Inflater needs a dictionary
            </exception>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.inf">
      <summary>
            Decompressor for this stream
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.inputBuffer">
      <summary>
        <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer">Input buffer</see> for this stream.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.csize">
      <summary>
            The compressed size
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner">
      <summary>
            Get/set flag indicating ownership of underlying stream.
            When the flag is true <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Close" /> will close the underlying stream also.
            </summary>
      <remarks>
            The default value is true.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Available">
      <summary>
            Returns 0 once the end of the stream (EOF) has been reached.
            Otherwise returns 1.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanRead">
      <summary>
            Gets a value indicating whether the current stream supports reading
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanSeek">
      <summary>
            Gets a value of false indicating seeking is not supported for this stream.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanWrite">
      <summary>
            Gets a value of false indicating that this stream is not writeable.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Length">
      <summary>
            A value representing the length of the stream in bytes.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Position">
      <summary>
            The current position within the stream.
            Throws a NotSupportedException when attempting to set the position
            </summary>
      <exception cref="T:System.NotSupportedException">Attempting to set the position</exception>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.GZip.GZipInputStream.crc">
      <summary>
            CRC-32 value for uncompressed data
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipInputStream.#ctor(System.IO.Stream)">
      <summary>
            Creates a GZipInputStream with the default buffer size
            </summary>
      <param name="baseInputStream">
            The stream to read compressed data from (baseInputStream GZIP format)
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipInputStream.#ctor(System.IO.Stream,System.Int32)">
      <summary>
            Creates a GZIPInputStream with the specified buffer size
            </summary>
      <param name="baseInputStream">
            The stream to read compressed data from (baseInputStream GZIP format)
            </param>
      <param name="size">
            Size of the buffer to use
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipInputStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Reads uncompressed data into an array of bytes
            </summary>
      <param name="buffer">
            The buffer to read uncompressed data into
            </param>
      <param name="offset">
            The offset indicating where the data should be placed
            </param>
      <param name="count">
            The number of uncompressed bytes to be read
            </param>
      <returns>Returns the number of bytes actually read.</returns>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.GZip.GZipOutputStream">
      <summary>
             This filter stream is used to compress a stream into a "GZIP" stream.
             The "GZIP" format is described in RFC 1952.
            
             author of the original java version : John Leuner
             </summary>
      <example> This sample shows how to gzip a file
             <code>
             using System;
             using System.IO;
             
             using ICSharpCode.SharpZipLib.GZip;
             using ICSharpCode.SharpZipLib.Core;
             
             class MainClass
             {
             	public static void Main(string[] args)
             	{
             			using (Stream s = new GZipOutputStream(File.Create(args[0] + ".gz")))
             			using (FileStream fs = File.OpenRead(args[0])) {
             				byte[] writeData = new byte[4096];
             				Streamutils.Copy(s, fs, writeData);
             			}
             		}
             	}
             }	
             </code></example>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream">
      <summary>
            A special stream deflating or compressing the bytes that are
            written to it.  It uses a Deflater to perform actual deflating.<br />
            Authors of the original java version : Tom Tromey, Jochen Hoenicke 
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream)">
      <summary>
            Creates a new DeflaterOutputStream with a default Deflater and default buffer size.
            </summary>
      <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Deflater)">
      <summary>
            Creates a new DeflaterOutputStream with the given Deflater and
            default buffer size.
            </summary>
      <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
      <param name="deflater">
            the underlying deflater.
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Deflater,System.Int32)">
      <summary>
            Creates a new DeflaterOutputStream with the given Deflater and
            buffer size.
            </summary>
      <param name="baseOutputStream">
            The output stream where deflated output is written.
            </param>
      <param name="deflater">
            The underlying deflater to use
            </param>
      <param name="bufferSize">
            The buffer size in bytes to use when deflating (minimum value 512)
            </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            bufsize is less than or equal to zero.
            </exception>
      <exception cref="T:System.ArgumentException">
            baseOutputStream does not support writing
            </exception>
      <exception cref="T:System.ArgumentNullException">
            deflater instance is null
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Finish">
      <summary>
            Finishes the stream by calling finish() on the deflater. 
            </summary>
      <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            Not all input is deflated
            </exception>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.AESAuthCode">
      <summary>
            Returns the 10 byte AUTH CODE to be appended immediately following the AES data stream.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.EncryptBlock(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Encrypt a block of data
            </summary>
      <param name="buffer">
            Data to encrypt.  NOTE the original contents of the buffer are lost
            </param>
      <param name="offset">
            Offset of first byte in buffer to encrypt
            </param>
      <param name="length">
            Number of bytes in buffer to encrypt
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.InitializePassword(System.String)">
      <summary>
            Initializes encryption keys based on given <paramref name="password" />.
            </summary>
      <param name="password">The password.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Deflate">
      <summary>
            Deflates everything in the input buffers.  This will call
            <code>def.deflate()</code> until all bytes from the input buffers
            are processed.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
            Sets the current position of this stream to the given value. Not supported by this class!
            </summary>
      <param name="offset">The offset relative to the <paramref name="origin" /> to seek.</param>
      <param name="origin">The <see cref="T:System.IO.SeekOrigin" /> to seek from.</param>
      <returns>The new position in the stream.</returns>
      <exception cref="T:System.NotSupportedException">Any access</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.SetLength(System.Int64)">
      <summary>
            Sets the length of this stream to the given value. Not supported by this class!
            </summary>
      <param name="value">The new stream length.</param>
      <exception cref="T:System.NotSupportedException">Any access</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.ReadByte">
      <summary>
            Read a byte from stream advancing position by one
            </summary>
      <returns>The byte read cast to an int.  THe value is -1 if at the end of the stream.</returns>
      <exception cref="T:System.NotSupportedException">Any access</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Read a block of bytes from stream
            </summary>
      <param name="buffer">The buffer to store read data in.</param>
      <param name="offset">The offset to start storing at.</param>
      <param name="count">The maximum number of bytes to read.</param>
      <returns>The actual number of bytes read.  Zero if end of stream is detected.</returns>
      <exception cref="T:System.NotSupportedException">Any access</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <summary>
            Asynchronous reads are not supported a NotSupportedException is always thrown
            </summary>
      <param name="buffer">The buffer to read into.</param>
      <param name="offset">The offset to start storing data at.</param>
      <param name="count">The number of bytes to read</param>
      <param name="callback">The async callback to use.</param>
      <param name="state">The state to use.</param>
      <returns>Returns an <see cref="T:System.IAsyncResult" /></returns>
      <exception cref="T:System.NotSupportedException">Any access</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <summary>
            Asynchronous writes arent supported, a NotSupportedException is always thrown
            </summary>
      <param name="buffer">The buffer to write.</param>
      <param name="offset">The offset to begin writing at.</param>
      <param name="count">The number of bytes to write.</param>
      <param name="callback">The <see cref="T:System.AsyncCallback" /> to use.</param>
      <param name="state">The state object.</param>
      <returns>Returns an IAsyncResult.</returns>
      <exception cref="T:System.NotSupportedException">Any access</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Flush">
      <summary>
            Flushes the stream by calling <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Flush">Flush</see> on the deflater and then
            on the underlying stream.  This ensures that all bytes are flushed.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Close">
      <summary>
            Calls <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Finish" /> and closes the underlying
            stream when <see cref="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner"></see> is true.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.WriteByte(System.Byte)">
      <summary>
            Writes a single byte to the compressed output stream.
            </summary>
      <param name="value">
            The byte value.
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Writes bytes from an array to the compressed stream.
            </summary>
      <param name="buffer">
            The byte array
            </param>
      <param name="offset">
            The offset into the byte array where to start.
            </param>
      <param name="count">
            The number of bytes to write.
            </param>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.deflater_">
      <summary>
            The deflater which is used to deflate the stream.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.baseOutputStream_">
      <summary>
            Base stream the deflater depends on.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner">
      <summary>
            Get/set flag indicating ownership of the underlying stream.
            When the flag is true <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Close"></see> will close the underlying stream also.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanPatchEntries">
      <summary>
            Allows client to determine if an entry can be patched after its added
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Password">
      <summary>
            Get/set the password used for encryption.
            </summary>
      <remarks>When set to null or if the password is empty no encryption is performed</remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanRead">
      <summary>
            Gets value indicating stream can be read from
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanSeek">
      <summary>
            Gets a value indicating if seeking is supported for this stream
            This property always returns false
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanWrite">
      <summary>
            Get value indicating if this stream supports writing
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Length">
      <summary>
            Get current length of stream
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Position">
      <summary>
            Gets the current position within the stream.
            </summary>
      <exception cref="T:System.NotSupportedException">Any attempt to set position</exception>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.crc">
      <summary>
            CRC-32 value for uncompressed data
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.#ctor(System.IO.Stream)">
      <summary>
            Creates a GzipOutputStream with the default buffer size
            </summary>
      <param name="baseOutputStream">
            The stream to read data (to be compressed) from
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.#ctor(System.IO.Stream,System.Int32)">
      <summary>
            Creates a GZipOutputStream with the specified buffer size
            </summary>
      <param name="baseOutputStream">
            The stream to read data (to be compressed) from
            </param>
      <param name="size">
            Size of the buffer to use
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.SetLevel(System.Int32)">
      <summary>
            Sets the active compression level (1-9).  The new level will be activated
            immediately.
            </summary>
      <param name="level">The compression level to set.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            Level specified is not supported.
            </exception>
      <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Deflater" />
    </member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.GetLevel">
      <summary>
            Get the current compression level.
            </summary>
      <returns>The current compression level.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Write given buffer to output updating crc
            </summary>
      <param name="buffer">Buffer to write</param>
      <param name="offset">Offset of first byte in buf to write</param>
      <param name="count">Number of bytes to write</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.Close">
      <summary>
            Writes remaining compressed output data to the output stream
            and closes it.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.Finish">
      <summary>
            Finish compression and write any footer information required to stream
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Deflater">
      <summary>
             This is the Deflater class.  The deflater class compresses input
             with the deflate algorithm described in RFC 1951.  It has several
             compression levels and three different strategies described below.
            
             This class is <i>not</i> thread safe.  This is inherent in the API, due
             to the split of deflate and setInput.
             
             author of the original java version : Jochen Hoenicke
             </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.BEST_COMPRESSION">
      <summary>
            The best and slowest compression level.  This tries to find very
            long and distant string repetitions.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.BEST_SPEED">
      <summary>
            The worst but fastest compression level.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.DEFAULT_COMPRESSION">
      <summary>
            The default compression level.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.NO_COMPRESSION">
      <summary>
            This level won't compress at all but output uncompressed blocks.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.DEFLATED">
      <summary>
            The compression method.  This is the only method supported so far.
            There is no need to use this constant at all.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.#ctor">
      <summary>
            Creates a new deflater with default compression level.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32)">
      <summary>
            Creates a new deflater with given compression level.
            </summary>
      <param name="level">
            the compression level, a value between NO_COMPRESSION
            and BEST_COMPRESSION, or DEFAULT_COMPRESSION.
            </param>
      <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32,System.Boolean)">
      <summary>
            Creates a new deflater with given compression level.
            </summary>
      <param name="level">
            the compression level, a value between NO_COMPRESSION
            and BEST_COMPRESSION.
            </param>
      <param name="noZlibHeaderOrFooter">
            true, if we should suppress the Zlib/RFC1950 header at the
            beginning and the adler checksum at the end of the output.  This is
            useful for the GZIP/PKZIP formats.
            </param>
      <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Reset">
      <summary>
            Resets the deflater.  The deflater acts afterwards as if it was
            just created with the same compression level and strategy as it
            had before.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Flush">
      <summary>
            Flushes the current input block.  Further calls to deflate() will
            produce enough output to inflate everything in the current input
            block.  This is not part of Sun's JDK so I have made it package
            private.  It is used by DeflaterOutputStream to implement
            flush().
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Finish">
      <summary>
            Finishes the deflater with the current input block.  It is an error
            to give more input after this method was called.  This method must
            be called to force all bytes to be flushed.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[])">
      <summary>
            Sets the data which should be compressed next.  This should be only
            called when needsInput indicates that more input is needed.
            If you call setInput when needsInput() returns false, the
            previous input that is still pending will be thrown away.
            The given byte array should not be changed, before needsInput() returns
            true again.
            This call is equivalent to <code>setInput(input, 0, input.length)</code>.
            </summary>
      <param name="input">
            the buffer containing the input data.
            </param>
      <exception cref="T:System.InvalidOperationException">
            if the buffer was finished() or ended().
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Sets the data which should be compressed next.  This should be
            only called when needsInput indicates that more input is needed.
            The given byte array should not be changed, before needsInput() returns
            true again.
            </summary>
      <param name="input">
            the buffer containing the input data.
            </param>
      <param name="offset">
            the start of the data.
            </param>
      <param name="count">
            the number of data bytes of input.
            </param>
      <exception cref="T:System.InvalidOperationException">
            if the buffer was Finish()ed or if previous input is still pending.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetLevel(System.Int32)">
      <summary>
            Sets the compression level.  There is no guarantee of the exact
            position of the change, but if you call this when needsInput is
            true the change of compression level will occur somewhere near
            before the end of the so far given input.
            </summary>
      <param name="level">
            the new compression level.
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.GetLevel">
      <summary>
            Get current compression level
            </summary>
      <returns>Returns the current compression level</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetStrategy(ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy)">
      <summary>
            Sets the compression strategy. Strategy is one of
            DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED.  For the exact
            position where the strategy is changed, the same as for
            SetLevel() applies.
            </summary>
      <param name="strategy">
            The new compression strategy.
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[])">
      <summary>
            Deflates the current input block with to the given array.
            </summary>
      <param name="output">
            The buffer where compressed data is stored
            </param>
      <returns>
            The number of compressed bytes added to the output, or 0 if either
            IsNeedingInput() or IsFinished returns true or length is zero.
            </returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Deflates the current input block to the given array.
            </summary>
      <param name="output">
            Buffer to store the compressed data.
            </param>
      <param name="offset">
            Offset into the output array.
            </param>
      <param name="length">
            The maximum number of bytes that may be stored.
            </param>
      <returns>
            The number of compressed bytes added to the output, or 0 if either
            needsInput() or finished() returns true or length is zero.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            If Finish() was previously called.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            If offset or length don't match the array length.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[])">
      <summary>
            Sets the dictionary which should be used in the deflate process.
            This call is equivalent to <code>setDictionary(dict, 0, dict.Length)</code>.
            </summary>
      <param name="dictionary">
            the dictionary.
            </param>
      <exception cref="T:System.InvalidOperationException">
            if SetInput () or Deflate () were already called or another dictionary was already set.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Sets the dictionary which should be used in the deflate process.
            The dictionary is a byte array containing strings that are
            likely to occur in the data which should be compressed.  The
            dictionary is not stored in the compressed output, only a
            checksum.  To decompress the output you need to supply the same
            dictionary again.
            </summary>
      <param name="dictionary">
            The dictionary data
            </param>
      <param name="index">
            The index where dictionary information commences.
            </param>
      <param name="count">
            The number of bytes in the dictionary.
            </param>
      <exception cref="T:System.InvalidOperationException">
            If SetInput () or Deflate() were already called or another dictionary was already set.
            </exception>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Adler">
      <summary>
            Gets the current adler checksum of the data that was processed so far.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.TotalIn">
      <summary>
            Gets the number of input bytes processed so far.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.TotalOut">
      <summary>
            Gets the number of output bytes so far.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.IsFinished">
      <summary>
            Returns true if the stream was finished and no more output bytes
            are available.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.IsNeedingInput">
      <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput(). 
            NOTE: This method can also return true when the stream
            was finished.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants">
      <summary>
            This class contains constants used for deflation.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEBUGGING">
      <summary>
            Set to true to enable debugging
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.STORED_BLOCK">
      <summary>
            Written to Zip file to identify a stored block
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.STATIC_TREES">
      <summary>
            Identifies static tree in Zip file
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DYN_TREES">
      <summary>
            Identifies dynamic tree in Zip file
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.PRESET_DICT">
      <summary>
            Header flag indicating a preset dictionary for deflation
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEFAULT_MEM_LEVEL">
      <summary>
            Sets internal buffer sizes for Huffman encoding
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_MATCH">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MIN_MATCH">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_WBITS">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.WSIZE">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.WMASK">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_BITS">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_SIZE">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_MASK">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_SHIFT">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MIN_LOOKAHEAD">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_DIST">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.PENDING_BUF_SIZE">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_STORED">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_FAST">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_SLOW">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_BLOCK_SIZE">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.GOOD_LENGTH">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_LAZY">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.NICE_LENGTH">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_CHAIN">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.COMPR_FUNC">
      <summary>
            Internal compression engine constant
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy">
      <summary>
            Strategies for deflater
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy.Default">
      <summary>
            The default strategy
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy.Filtered">
      <summary>
            This strategy will only allow longer string repetitions.  It is
            useful for random data with a small character set.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy.HuffmanOnly">
      <summary>
            This strategy will not look for string repetitions at all.  It
            only encodes with Huffman trees (which means, that more common
            characters get a smaller encoding.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine">
      <summary>
            Low level compression engine for deflate algorithm which uses a 32K sliding window
            with secondary compression from Huffman/Shannon-Fano codes.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.#ctor(ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending)">
      <summary>
            Construct instance with pending buffer
            </summary>
      <param name="pending">
            Pending buffer to use
            </param>&gt;
        </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Deflate(System.Boolean,System.Boolean)">
      <summary>
            Deflate drives actual compression of data
            </summary>
      <param name="flush">True to flush input buffers</param>
      <param name="finish">Finish deflation with the current input.</param>
      <returns>Returns true if progress has been made.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Sets input data to be deflated.  Should only be called when <code>NeedsInput()</code>
            returns true
            </summary>
      <param name="buffer">The buffer containing input data.</param>
      <param name="offset">The offset of the first byte of data.</param>
      <param name="count">The number of bytes of data to use as input.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.NeedsInput">
      <summary>
            Determines if more <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">input</see> is needed.
            </summary>
      <returns>Return true if input is needed via <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">SetInput</see></returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetDictionary(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Set compression dictionary
            </summary>
      <param name="buffer">The buffer containing the dictionary data</param>
      <param name="offset">The offset in the buffer for the first byte of data</param>
      <param name="length">The length of the dictionary data.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Reset">
      <summary>
            Reset internal state
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.ResetAdler">
      <summary>
            Reset Adler checksum
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetLevel(System.Int32)">
      <summary>
            Set the deflate level (0-9)
            </summary>
      <param name="level">The value to set the level to.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.FillWindow">
      <summary>
            Fill the window
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Adler">
      <summary>
            Get current value of Adler checksum
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.TotalIn">
      <summary>
            Total data processed
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Strategy">
      <summary>
            Get/set the <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy">deflate strategy</see></summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman">
      <summary>
            This is the DeflaterHuffman class.
            
            This class is <i>not</i> thread safe.  This is inherent in the API, due
            to the split of Deflate and SetInput.
            
            author of the original java version : Jochen Hoenicke
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.pending">
      <summary>
            Pending buffer to use
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.#ctor(ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending)">
      <summary>
            Construct instance with pending buffer
            </summary>
      <param name="pending">Pending buffer to use</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Reset">
      <summary>
            Reset internal state
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.SendAllTrees(System.Int32)">
      <summary>
            Write all trees to pending buffer
            </summary>
      <param name="blTreeCodes">The number/rank of treecodes to send.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.CompressBlock">
      <summary>
            Compress current buffer writing data to pending buffer
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushStoredBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
      <summary>
            Flush block to output with no compression
            </summary>
      <param name="stored">Data to write</param>
      <param name="storedOffset">Index of first byte to write</param>
      <param name="storedLength">Count of bytes to write</param>
      <param name="lastBlock">True if this is the last block</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
      <summary>
            Flush block to output with compression
            </summary>
      <param name="stored">Data to flush</param>
      <param name="storedOffset">Index of first byte to flush</param>
      <param name="storedLength">Count of bytes to flush</param>
      <param name="lastBlock">True if this is the last block</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.IsFull">
      <summary>
            Get value indicating if internal buffer is full
            </summary>
      <returns>true if buffer is full</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyLit(System.Int32)">
      <summary>
            Add literal to buffer
            </summary>
      <param name="literal">Literal value to add to buffer.</param>
      <returns>Value indicating internal buffer is full</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyDist(System.Int32,System.Int32)">
      <summary>
            Add distance code and length to literal and distance trees
            </summary>
      <param name="distance">Distance code</param>
      <param name="length">Length</param>
      <returns>Value indicating if internal buffer is full</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.BitReverse(System.Int32)">
      <summary>
            Reverse the bits of a 16 bit value.
            </summary>
      <param name="toReverse">Value to reverse bits</param>
      <returns>Value with bits reversed</returns>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending">
      <summary>
            This class stores the pending output of the Deflater.
            
            author of the original java version : Jochen Hoenicke
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer">
      <summary>
            This class is general purpose class for writing data to a buffer.
            
            It allows you to write bits as well as bytes
            Based on DeflaterPending.java
            
            author of the original java version : Jochen Hoenicke
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.#ctor">
      <summary>
            construct instance using default buffer size of 4096
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.#ctor(System.Int32)">
      <summary>
            construct instance using specified buffer size
            </summary>
      <param name="bufferSize">
            size to use for internal buffer
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.Reset">
      <summary>
            Clear internal state/buffers
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteByte(System.Int32)">
      <summary>
            Write a byte to buffer
            </summary>
      <param name="value">
            The value to write
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteShort(System.Int32)">
      <summary>
            Write a short value to buffer LSB first
            </summary>
      <param name="value">
            The value to write.
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteInt(System.Int32)">
      <summary>
            write an integer LSB first
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteBlock(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Write a block of data to buffer
            </summary>
      <param name="block">data to write</param>
      <param name="offset">offset of first byte to write</param>
      <param name="length">number of bytes to write</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.AlignToByte">
      <summary>
            Align internal buffer on a byte boundary
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteBits(System.Int32,System.Int32)">
      <summary>
            Write bits to internal buffer
            </summary>
      <param name="b">source of bits</param>
      <param name="count">number of bits to write</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteShortMSB(System.Int32)">
      <summary>
            Write a short value to internal buffer most significant byte first
            </summary>
      <param name="s">value to write</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.Flush(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Flushes the pending buffer into the given output array.  If the
            output array is to small, only a partial flush is done.
            </summary>
      <param name="output">The output array.</param>
      <param name="offset">The offset into output array.</param>
      <param name="length">The maximum number of bytes to store.</param>
      <returns>The number of bytes flushed.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.ToByteArray">
      <summary>
            Convert internal buffer to byte array.
            Buffer is empty on completion
            </summary>
      <returns>
            The internal buffer contents converted to a byte array.
            </returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.BitCount">
      <summary>
            The number of bits written to the buffer
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.IsFlushed">
      <summary>
            Indicates if buffer has been flushed
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending.#ctor">
      <summary>
            Construct instance with default buffer size
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Inflater">
      <summary>
             Inflater is used to decompress data that has been compressed according
             to the "deflate" standard described in rfc1951.
             
             By default Zlib (rfc1950) headers and footers are expected in the input.
             You can use constructor <code> public Inflater(bool noHeader)</code> passing true
             if there is no Zlib header information
            
             The usage is as following.  First you have to set some input with
             <code>SetInput()</code>, then Inflate() it.  If inflate doesn't
             inflate any bytes there may be three reasons:
             <ul><li>IsNeedingInput() returns true because the input buffer is empty.
             You have to provide more input with <code>SetInput()</code>.
             NOTE: IsNeedingInput() also returns true when, the stream is finished.
             </li><li>IsNeedingDictionary() returns true, you have to provide a preset
                dictionary with <code>SetDictionary()</code>.</li><li>IsFinished returns true, the inflater has finished.</li></ul>
             Once the first output byte is produced, a dictionary will not be
             needed at a later stage.
            
             author of the original java version : John Leuner, Jochen Hoenicke
             </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.DECODE_HEADER">
      <summary>
            These are the possible states for an inflater
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.#ctor">
      <summary>
            Creates a new inflater or RFC1951 decompressor
            RFC1950/Zlib headers and footers will be expected in the input data
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.#ctor(System.Boolean)">
      <summary>
            Creates a new inflater.
            </summary>
      <param name="noHeader">
            True if no RFC1950/Zlib header and footer fields are expected in the input data
            
            This is used for GZIPed/Zipped input.
            
            For compatibility with
            Sun JDK you should provide one byte of input more than needed in
            this case.
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Reset">
      <summary>
            Resets the inflater so that a new stream can be decompressed.  All
            pending input and output will be discarded.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[])">
      <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
      <param name="buffer">
            The dictionary.
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
      <param name="buffer">
            The dictionary.
            </param>
      <param name="index">
            The index into buffer where the dictionary starts.
            </param>
      <param name="count">
            The number of bytes in the dictionary.
            </param>
      <exception cref="T:System.InvalidOperationException">
            No dictionary is needed.
            </exception>
      <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            The adler checksum for the buffer is invalid
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[])">
      <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
      <param name="buffer">
            the input.
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
      <param name="buffer">
            The source of input data
            </param>
      <param name="index">
            The index into buffer where the input starts.
            </param>
      <param name="count">
            The number of bytes of input to use.
            </param>
      <exception cref="T:System.InvalidOperationException">
            No input is needed.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The index and/or count are wrong.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[])">
      <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether IsNeedingDictionary(),
            IsNeedingInput() or IsFinished() returns true, to determine why no
            further output is produced.
            </summary>
      <param name="buffer">
            the output buffer.
            </param>
      <returns>
            The number of bytes written to the buffer, 0 if no further
            output can be produced.
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
            if buffer has length 0.
            </exception>
      <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether needsDictionary(),
            needsInput() or finished() returns true, to determine why no
            further output is produced.
            </summary>
      <param name="buffer">
            the output buffer.
            </param>
      <param name="offset">
            the offset in buffer where storing starts.
            </param>
      <param name="count">
            the maximum number of bytes to output.
            </param>
      <returns>
            the number of bytes written to the buffer, 0 if no further output can be produced.
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
            if count is less than 0.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            if the index and / or count are wrong.
            </exception>
      <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.IsNeedingInput">
      <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput(). 
            NOTE: This method also returns true when the stream is finished.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.IsNeedingDictionary">
      <summary>
            Returns true, if a preset dictionary is needed to inflate the input.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.IsFinished">
      <summary>
            Returns true, if the inflater has finished.  This means, that no
            input is needed and no output can be produced.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Adler">
      <summary>
            Gets the adler checksum.  This is either the checksum of all
            uncompressed bytes returned by inflate(), or if needsDictionary()
            returns true (and thus no output was yet produced) this is the
            adler checksum of the expected dictionary.
            </summary>
      <returns>
            the adler checksum.
            </returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.TotalOut">
      <summary>
            Gets the total number of output bytes returned by Inflate().
            </summary>
      <returns>
            the total number of output bytes.
            </returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.TotalIn">
      <summary>
            Gets the total number of processed compressed input bytes.
            </summary>
      <returns>
            The total number of bytes of processed input bytes.
            </returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.RemainingInput">
      <summary>
            Gets the number of unprocessed input bytes.  Useful, if the end of the
            stream is reached and you want to further process the bytes after
            the deflate stream.
            </summary>
      <returns>
            The number of bytes of the input which have not been processed.
            </returns>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree">
      <summary>
            Huffman tree used for inflation
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree.defLitLenTree">
      <summary>
            Literal length tree
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree.defDistTree">
      <summary>
            Distance tree
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree.#ctor(System.Byte[])">
      <summary>
            Constructs a Huffman tree from the array of code lengths.
            </summary>
      <param name="codeLengths">
            the array of code lengths
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree.GetSymbol(ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator)">
      <summary>
            Reads the next symbol from input.  The symbol is encoded using the
            huffman tree.
            </summary>
      <param name="input">
            input the input source.
            </param>
      <returns>
            the next symbol, or -1 if not enough input is available.
            </returns>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer">
      <summary>
            An input buffer customised for use by <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream" /></summary>
      <remarks>
            The buffer supports decryption of incoming data.
            </remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer" /> with a default buffer size
            </summary>
      <param name="stream">The stream to buffer.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream,System.Int32)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer" /></summary>
      <param name="stream">The stream to buffer.</param>
      <param name="bufferSize">The size to use for the buffer</param>
      <remarks>A minimum buffer size of 1KB is permitted.  Lower sizes are treated as 1KB.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.SetInflaterInput(ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
      <summary>
            Call <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)" /> passing the current clear text buffer contents.
            </summary>
      <param name="inflater">The inflater to set input for.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.Fill">
      <summary>
            Fill the buffer from the underlying input stream.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[])">
      <summary>
            Read a buffer directly from the input stream
            </summary>
      <param name="buffer">The buffer to fill</param>
      <returns>Returns the number of bytes read.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Read a buffer directly from the input stream
            </summary>
      <param name="outBuffer">The buffer to read into</param>
      <param name="offset">The offset to start reading data into.</param>
      <param name="length">The number of bytes to read.</param>
      <returns>Returns the number of bytes read.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadClearTextBuffer(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Read clear text data from the input stream.
            </summary>
      <param name="outBuffer">The buffer to add data to.</param>
      <param name="offset">The offset to start adding data at.</param>
      <param name="length">The number of bytes to read.</param>
      <returns>Returns the number of bytes actually read.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeByte">
      <summary>
            Read a <see cref="T:System.Byte" /> from the input stream.
            </summary>
      <returns>Returns the byte read.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeShort">
      <summary>
            Read an <see cref="T:System.Int16" /> in little endian byte order.
            </summary>
      <returns>The short value read case to an int.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeInt">
      <summary>
            Read an <see cref="T:System.Int32" /> in little endian byte order.
            </summary>
      <returns>The int value read.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeLong">
      <summary>
            Read a <see cref="T:System.Int64" /> in little endian byte order.
            </summary>
      <returns>The long value read.</returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawLength">
      <summary>
            Get the length of bytes bytes in the <see cref="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawData" /></summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawData">
      <summary>
            Get the contents of the raw data buffer.
            </summary>
      <remarks>This may contain encrypted data.</remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearTextLength">
      <summary>
            Get the number of useable bytes in <see cref="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearText" /></summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearText">
      <summary>
            Get the contents of the clear text buffer.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.Available">
      <summary>
            Get/set the number of bytes available
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.CryptoTransform">
      <summary>
            Get/set the <see cref="T:System.Security.Cryptography.ICryptoTransform" /> to apply to any data.
            </summary>
      <remarks>Set this value to null to have no transform applied.</remarks>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow">
      <summary>
            Contains the output from the Inflation process.
            We need to have a window so that we can refer backwards into the output stream
            to repeat stuff.<br />
            Author of the original java version : John Leuner
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.Write(System.Int32)">
      <summary>
            Write a byte to this output window
            </summary>
      <param name="value">value to write</param>
      <exception cref="T:System.InvalidOperationException">
            if window is full
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.Repeat(System.Int32,System.Int32)">
      <summary>
            Append a byte pattern already in the window itself
            </summary>
      <param name="length">length of pattern to copy</param>
      <param name="distance">distance from end of window pattern occurs</param>
      <exception cref="T:System.InvalidOperationException">
            If the repeated data overflows the window
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyStored(ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator,System.Int32)">
      <summary>
            Copy from input manipulator to internal window
            </summary>
      <param name="input">source of data</param>
      <param name="length">length of data to copy</param>
      <returns>the number of bytes copied</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyDict(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Copy dictionary to window
            </summary>
      <param name="dictionary">source dictionary</param>
      <param name="offset">offset of start in source dictionary</param>
      <param name="length">length of dictionary</param>
      <exception cref="T:System.InvalidOperationException">
            If window isnt empty
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetFreeSpace">
      <summary>
            Get remaining unfilled space in window
            </summary>
      <returns>Number of bytes left in window</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">
      <summary>
            Get bytes available for output in window
            </summary>
      <returns>Number of bytes filled</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyOutput(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Copy contents of window to output
            </summary>
      <param name="output">buffer to copy to</param>
      <param name="offset">offset to start at</param>
      <param name="len">number of bytes to count</param>
      <returns>The number of bytes copied</returns>
      <exception cref="T:System.InvalidOperationException">
            If a window underflow occurs
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.Reset">
      <summary>
            Reset by clearing window so <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">GetAvailable</see> returns 0
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator">
      <summary>
             This class allows us to retrieve a specified number of bits from
             the input buffer, as well as copy big byte blocks.
            
             It uses an int buffer to store up to 31 bits for direct
             manipulation.  This guarantees that we can get at least 16 bits,
             but we only need at most 15, so this is all safe.
            
             There are some optimizations in this class, for example, you must
             never peek more than 8 bits more than needed, and you must first
             peek bits before you may drop them.  This is not a general purpose
             class but optimized for the behaviour of the Inflater.
            
             authors of the original java version : John Leuner, Jochen Hoenicke
             </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.#ctor">
      <summary>
            Constructs a default StreamManipulator with all buffers empty
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)">
      <summary>
            Get the next sequence of bits but don't increase input pointer.  bitCount must be
            less or equal 16 and if this call succeeds, you must drop
            at least n - 8 bits in the next call.
            </summary>
      <param name="bitCount">The number of bits to peek.</param>
      <returns>
            the value of the bits, or -1 if not enough bits available.  */
            </returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)">
      <summary>
            Drops the next n bits from the input.  You should have called PeekBits
            with a bigger or equal n before, to make sure that enough bits are in
            the bit buffer.
            </summary>
      <param name="bitCount">The number of bits to drop.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.GetBits(System.Int32)">
      <summary>
            Gets the next n bits and increases input pointer.  This is equivalent
            to <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)" /> followed by <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)" />, except for correct error handling.
            </summary>
      <param name="bitCount">The number of bits to retrieve.</param>
      <returns>
            the value of the bits, or -1 if not enough bits available.
            </returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SkipToByteBoundary">
      <summary>
            Skips to the next byte boundary.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.CopyBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Copies bytes from input buffer to output buffer starting
            at output[offset].  You have to make sure, that the buffer is
            byte aligned.  If not enough bytes are available, copies fewer
            bytes.
            </summary>
      <param name="output">
            The buffer to copy bytes to.
            </param>
      <param name="offset">
            The offset in the buffer at which copying starts
            </param>
      <param name="length">
            The length to copy, 0 is allowed.
            </param>
      <returns>
            The number of bytes copied, 0 if no bytes were available.
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
            Length is less than zero
            </exception>
      <exception cref="T:System.InvalidOperationException">
            Bit buffer isnt byte aligned
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.Reset">
      <summary>
            Resets state and empties internal buffers
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SetInput(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Add more input for consumption.
            Only call when IsNeedingInput returns true
            </summary>
      <param name="buffer">data to be input</param>
      <param name="offset">offset of first byte of input</param>
      <param name="count">number of bytes of input to add.</param>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBits">
      <summary>
            Gets the number of bits available in the bit buffer.  This must be
            only called when a previous PeekBits() returned -1.
            </summary>
      <returns>
            the number of bits available.
            </returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBytes">
      <summary>
            Gets the number of bytes available.
            </summary>
      <returns>
            The number of bytes available.
            </returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.IsNeedingInput">
      <summary>
            Returns true when SetInput can be called
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.FastZipEvents">
      <summary>
            FastZipEvents supports all events applicable to <see cref="T:ICSharpCode.SharpZipLib.Zip.FastZip">FastZip</see> operations.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.FastZipEvents.ProcessDirectory">
      <summary>
            Delegate to invoke when processing directories.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.FastZipEvents.ProcessFile">
      <summary>
            Delegate to invoke when processing files.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.FastZipEvents.Progress">
      <summary>
            Delegate to invoke during processing of files.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.FastZipEvents.CompletedFile">
      <summary>
            Delegate to invoke when processing for a file has been completed.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.FastZipEvents.DirectoryFailure">
      <summary>
            Delegate to invoke when processing directory failures.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.FastZipEvents.FileFailure">
      <summary>
            Delegate to invoke when processing file failures.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZipEvents.OnDirectoryFailure(System.String,System.Exception)">
      <summary>
            Raise the <see cref="F:ICSharpCode.SharpZipLib.Zip.FastZipEvents.DirectoryFailure">directory failure</see> event.
            </summary>
      <param name="directory">The directory causing the failure.</param>
      <param name="e">The exception for this event.</param>
      <returns>A boolean indicating if execution should continue or not.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZipEvents.OnFileFailure(System.String,System.Exception)">
      <summary>
            Fires the <see cref="F:ICSharpCode.SharpZipLib.Zip.FastZipEvents.FileFailure"> file failure handler delegate</see>.
            </summary>
      <param name="file">The file causing the failure.</param>
      <param name="e">The exception for this failure.</param>
      <returns>A boolean indicating if execution should continue or not.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZipEvents.OnProcessFile(System.String)">
      <summary>
            Fires the <see cref="F:ICSharpCode.SharpZipLib.Zip.FastZipEvents.ProcessFile">ProcessFile delegate</see>.
            </summary>
      <param name="file">The file being processed.</param>
      <returns>A boolean indicating if execution should continue or not.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZipEvents.OnCompletedFile(System.String)">
      <summary>
            Fires the <see cref="F:ICSharpCode.SharpZipLib.Zip.FastZipEvents.CompletedFile" /> delegate
            </summary>
      <param name="file">The file whose processing has been completed.</param>
      <returns>A boolean indicating if execution should continue or not.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZipEvents.OnProcessDirectory(System.String,System.Boolean)">
      <summary>
            Fires the <see cref="F:ICSharpCode.SharpZipLib.Zip.FastZipEvents.ProcessDirectory">process directory</see> delegate.
            </summary>
      <param name="directory">The directory being processed.</param>
      <param name="hasMatchingFiles">Flag indicating if the directory has matching files as determined by the current filter.</param>
      <returns>A <see cref="T:System.Boolean" /> of true if the operation should continue; false otherwise.</returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.FastZipEvents.ProgressInterval">
      <summary>
            The minimum timespan between <see cref="F:ICSharpCode.SharpZipLib.Zip.FastZipEvents.Progress" /> events.
            </summary>
      <value>The minimum period of time between <see cref="F:ICSharpCode.SharpZipLib.Zip.FastZipEvents.Progress" /> events.</value>
      <seealso cref="F:ICSharpCode.SharpZipLib.Zip.FastZipEvents.Progress" />
      <remarks>The default interval is three seconds.</remarks>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.FastZip">
      <summary>
            FastZip provides facilities for creating and extracting zip files.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.#ctor">
      <summary>
            Initialise a default instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.FastZip" />.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.#ctor(ICSharpCode.SharpZipLib.Zip.FastZipEvents)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.FastZip" /></summary>
      <param name="events">The <see cref="T:ICSharpCode.SharpZipLib.Zip.FastZipEvents">events</see> to use during operations.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.CreateZip(System.String,System.String,System.Boolean,System.String,System.String)">
      <summary>
            Create a zip file.
            </summary>
      <param name="zipFileName">The name of the zip file to create.</param>
      <param name="sourceDirectory">The directory to source files from.</param>
      <param name="recurse">True to recurse directories, false for no recursion.</param>
      <param name="fileFilter">The <see cref="T:ICSharpCode.SharpZipLib.Core.PathFilter">file filter</see> to apply.</param>
      <param name="directoryFilter">The <see cref="T:ICSharpCode.SharpZipLib.Core.PathFilter">directory filter</see> to apply.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.CreateZip(System.String,System.String,System.Boolean,System.String)">
      <summary>
            Create a zip file/archive.
            </summary>
      <param name="zipFileName">The name of the zip file to create.</param>
      <param name="sourceDirectory">The directory to obtain files and directories from.</param>
      <param name="recurse">True to recurse directories, false for no recursion.</param>
      <param name="fileFilter">The file filter to apply.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.CreateZip(System.IO.Stream,System.String,System.Boolean,System.String,System.String)">
      <summary>
            Create a zip archive sending output to the <paramref name="outputStream" /> passed.
            </summary>
      <param name="outputStream">The stream to write archive data to.</param>
      <param name="sourceDirectory">The directory to source files from.</param>
      <param name="recurse">True to recurse directories, false for no recursion.</param>
      <param name="fileFilter">The <see cref="T:ICSharpCode.SharpZipLib.Core.PathFilter">file filter</see> to apply.</param>
      <param name="directoryFilter">The <see cref="T:ICSharpCode.SharpZipLib.Core.PathFilter">directory filter</see> to apply.</param>
      <remarks>The <paramref name="outputStream" /> is closed after creation.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.ExtractZip(System.String,System.String,System.String)">
      <summary>
            Extract the contents of a zip file.
            </summary>
      <param name="zipFileName">The zip file to extract from.</param>
      <param name="targetDirectory">The directory to save extracted information in.</param>
      <param name="fileFilter">A filter to apply to files.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.ExtractZip(System.String,System.String,ICSharpCode.SharpZipLib.Zip.FastZip.Overwrite,ICSharpCode.SharpZipLib.Zip.FastZip.ConfirmOverwriteDelegate,System.String,System.String,System.Boolean)">
      <summary>
            Extract the contents of a zip file.
            </summary>
      <param name="zipFileName">The zip file to extract from.</param>
      <param name="targetDirectory">The directory to save extracted information in.</param>
      <param name="overwrite">The style of <see cref="T:ICSharpCode.SharpZipLib.Zip.FastZip.Overwrite">overwriting</see> to apply.</param>
      <param name="confirmDelegate">A delegate to invoke when confirming overwriting.</param>
      <param name="fileFilter">A filter to apply to files.</param>
      <param name="directoryFilter">A filter to apply to directories.</param>
      <param name="restoreDateTime">Flag indicating whether to restore the date and time for extracted files.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.ExtractZip(System.IO.Stream,System.String,ICSharpCode.SharpZipLib.Zip.FastZip.Overwrite,ICSharpCode.SharpZipLib.Zip.FastZip.ConfirmOverwriteDelegate,System.String,System.String,System.Boolean,System.Boolean)">
      <summary>
            Extract the contents of a zip file held in a stream.
            </summary>
      <param name="inputStream">The seekable input stream containing the zip to extract from.</param>
      <param name="targetDirectory">The directory to save extracted information in.</param>
      <param name="overwrite">The style of <see cref="T:ICSharpCode.SharpZipLib.Zip.FastZip.Overwrite">overwriting</see> to apply.</param>
      <param name="confirmDelegate">A delegate to invoke when confirming overwriting.</param>
      <param name="fileFilter">A filter to apply to files.</param>
      <param name="directoryFilter">A filter to apply to directories.</param>
      <param name="restoreDateTime">Flag indicating whether to restore the date and time for extracted files.</param>
      <param name="isStreamOwner">Flag indicating whether the inputStream will be closed by this method.</param>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.FastZip.CreateEmptyDirectories">
      <summary>
            Get/set a value indicating wether empty directories should be created.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.FastZip.Password">
      <summary>
            Get / set the password value.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.FastZip.NameTransform">
      <summary>
            Get or set the <see cref="T:ICSharpCode.SharpZipLib.Core.INameTransform"></see> active when creating Zip files.
            </summary>
      <seealso cref="P:ICSharpCode.SharpZipLib.Zip.FastZip.EntryFactory">
      </seealso>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.FastZip.EntryFactory">
      <summary>
            Get or set the <see cref="T:ICSharpCode.SharpZipLib.Zip.IEntryFactory"></see> active when creating Zip files.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.FastZip.UseZip64">
      <summary>
            Gets or sets the setting for <see cref="P:ICSharpCode.SharpZipLib.Zip.FastZip.UseZip64">Zip64 handling when writing.</see></summary>
      <remarks>
            The default value is dynamic which is not backwards compatible with old
            programs and can cause problems with XP's built in compression which cant
            read Zip64 archives. However it does avoid the situation were a large file
            is added and cannot be completed correctly.
            NOTE: Setting the size for entries before they are added is the best solution!
            By default the EntryFactory used by FastZip will set fhe file size.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.FastZip.RestoreDateTimeOnExtract">
      <summary>
            Get/set a value indicating wether file dates and times should 
            be restored when extracting files from an archive.
            </summary>
      <remarks>The default value is false.</remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.FastZip.RestoreAttributesOnExtract">
      <summary>
            Get/set a value indicating wether file attributes should
            be restored during extract operations
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.FastZip.Overwrite">
      <summary>
            Defines the desired handling when overwriting files during extraction.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.FastZip.Overwrite.Prompt">
      <summary>
            Prompt the user to confirm overwriting
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.FastZip.Overwrite.Never">
      <summary>
            Never overwrite files.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.FastZip.Overwrite.Always">
      <summary>
            Always overwrite files.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.FastZip.ConfirmOverwriteDelegate">
      <summary>
            Delegate called when confirming overwriting of files.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.IEntryFactory">
      <summary>
            Defines factory methods for creating new <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry"></see> values.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IEntryFactory.MakeFileEntry(System.String)">
      <summary>
            Create a <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> for a file given its name
            </summary>
      <param name="fileName">The name of the file to create an entry for.</param>
      <returns>Returns a <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry">file entry</see> based on the <paramref name="fileName" /> passed.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IEntryFactory.MakeFileEntry(System.String,System.Boolean)">
      <summary>
            Create a <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> for a file given its name
            </summary>
      <param name="fileName">The name of the file to create an entry for.</param>
      <param name="useFileSystem">If true get details from the file system if the file exists.</param>
      <returns>Returns a <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry">file entry</see> based on the <paramref name="fileName" /> passed.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IEntryFactory.MakeDirectoryEntry(System.String)">
      <summary>
            Create a <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> for a directory given its name
            </summary>
      <param name="directoryName">The name of the directory to create an entry for.</param>
      <returns>Returns a <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry">directory entry</see> based on the <paramref name="directoryName" /> passed.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IEntryFactory.MakeDirectoryEntry(System.String,System.Boolean)">
      <summary>
            Create a <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> for a directory given its name
            </summary>
      <param name="directoryName">The name of the directory to create an entry for.</param>
      <param name="useFileSystem">If true get details from the file system for this directory if it exists.</param>
      <returns>Returns a <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry">directory entry</see> based on the <paramref name="directoryName" /> passed.</returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.IEntryFactory.NameTransform">
      <summary>
            Get/set the <see cref="T:ICSharpCode.SharpZipLib.Core.INameTransform"></see> applicable.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.WindowsNameTransform">
      <summary>
            WindowsNameTransform transforms <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile" /> names to windows compatible ones.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.WindowsNameTransform.MaxPath">
      <summary>
             The maximum windows path name permitted.
            </summary>
      <remarks>This may not valid for all windows systems - CE?, etc but I cant find the equivalent in the CLR.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.WindowsNameTransform.#ctor(System.String)">
      <summary>
            Initialises a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.WindowsNameTransform" /></summary>
      <param name="baseDirectory">
      </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.WindowsNameTransform.#ctor">
      <summary>
            Initialise a default instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.WindowsNameTransform" /></summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.WindowsNameTransform.TransformDirectory(System.String)">
      <summary>
            Transform a Zip directory name to a windows directory name.
            </summary>
      <param name="name">The directory name to transform.</param>
      <returns>The transformed name.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.WindowsNameTransform.TransformFile(System.String)">
      <summary>
            Transform a Zip format file name to a windows style one.
            </summary>
      <param name="name">The file name to transform.</param>
      <returns>The transformed name.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.WindowsNameTransform.IsValidName(System.String)">
      <summary>
            Test a name to see if it is a valid name for a windows filename as extracted from a Zip archive.
            </summary>
      <param name="name">The name to test.</param>
      <returns>Returns true if the name is a valid zip name; false otherwise.</returns>
      <remarks>The filename isnt a true windows path in some fundamental ways like no absolute paths, no rooted paths etc.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.WindowsNameTransform.MakeValidName(System.String,System.Char)">
      <summary>
            Force a name to be valid by replacing invalid characters with a fixed value
            </summary>
      <param name="name">The name to make valid</param>
      <param name="replacement">The replacement character to use for any invalid characters.</param>
      <returns>Returns a valid name</returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.WindowsNameTransform.BaseDirectory">
      <summary>
            Gets or sets a value containing the target directory to prefix values with.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.WindowsNameTransform.TrimIncomingPaths">
      <summary>
            Gets or sets a value indicating wether paths on incoming values should be removed.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.WindowsNameTransform.Replacement">
      <summary>
            Gets or set the character to replace invalid characters during transformations.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.UseZip64">
      <summary>
            Determines how entries are tested to see if they should use Zip64 extensions or not.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.UseZip64.Off">
      <summary>
            Zip64 will not be forced on entries during processing.
            </summary>
      <remarks>An entry can have this overridden if required <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.ForceZip64"></see></remarks>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.UseZip64.On">
      <summary>
            Zip64 should always be used.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.UseZip64.Dynamic">
      <summary>
            #ZipLib will determine use based on entry values when added to archive.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.CompressionMethod">
      <summary>
            The kind of compression used for an entry in an archive
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Stored">
      <summary>
            A direct copy of the file contents is held in the archive
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Deflated">
      <summary>
            Common Zip compression method using a sliding dictionary 
            of up to 32KB and secondary compression from Huffman/Shannon-Fano trees
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Deflate64">
      <summary>
            An extension to deflate with a 64KB window. Not supported by #Zip currently
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.BZip2">
      <summary>
            BZip2 compression. Not supported by #Zip.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.WinZipAES">
      <summary>
            WinZip special for AES encryption, Now supported by #Zip.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm">
      <summary>
            Identifies the encryption algorithm used for an entry
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.None">
      <summary>
            No encryption has been used.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.PkzipClassic">
      <summary>
            Encrypted using PKZIP 2.0 or 'classic' encryption.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Des">
      <summary>
            DES encryption has been used.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.RC2">
      <summary>
            RCS encryption has been used for encryption.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.TripleDes168">
      <summary>
            Triple DES encryption with 168 bit keys has been used for this entry.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.TripleDes112">
      <summary>
            Triple DES with 112 bit keys has been used for this entry.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Aes128">
      <summary>
            AES 128 has been used for encryption.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Aes192">
      <summary>
            AES 192 has been used for encryption.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Aes256">
      <summary>
            AES 256 has been used for encryption.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.RC2Corrected">
      <summary>
            RC2 corrected has been used for encryption.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Blowfish">
      <summary>
            Blowfish has been used for encryption.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Twofish">
      <summary>
            Twofish has been used for encryption.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.RC4">
      <summary>
            RC4 has been used for encryption.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Unknown">
      <summary>
            An unknown algorithm has been used for encryption.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags">
      <summary>
            Defines the contents of the general bit flags field for an archive entry.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Encrypted">
      <summary>
            Bit 0 if set indicates that the file is encrypted
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Method">
      <summary>
            Bits 1 and 2 - Two bits defining the compression method (only for Method 6 Imploding and 8,9 Deflating)
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Descriptor">
      <summary>
            Bit 3 if set indicates a trailing data desciptor is appended to the entry data
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.ReservedPKware4">
      <summary>
            Bit 4 is reserved for use with method 8 for enhanced deflation
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Patched">
      <summary>
            Bit 5 if set indicates the file contains Pkzip compressed patched data.
            Requires version 2.7 or greater.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.StrongEncryption">
      <summary>
            Bit 6 if set indicates strong encryption has been used for this entry.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Unused7">
      <summary>
            Bit 7 is currently unused
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Unused8">
      <summary>
            Bit 8 is currently unused
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Unused9">
      <summary>
            Bit 9 is currently unused
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Unused10">
      <summary>
            Bit 10 is currently unused
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.UnicodeText">
      <summary>
            Bit 11 if set indicates the filename and 
            comment fields for this file must be encoded using UTF-8.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.EnhancedCompress">
      <summary>
            Bit 12 is documented as being reserved by PKware for enhanced compression.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.HeaderMasked">
      <summary>
            Bit 13 if set indicates that values in the local header are masked to hide
            their actual values, and the central directory is encrypted.
            </summary>
      <remarks>
            Used when encrypting the central directory contents.
            </remarks>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.ReservedPkware14">
      <summary>
            Bit 14 is documented as being reserved for use by PKware
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.ReservedPkware15">
      <summary>
            Bit 15 is documented as being reserved for use by PKware
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipConstants">
      <summary>
            This class contains constants used for Zip format files
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VersionMadeBy">
      <summary>
            The version made by field for entries in the central header when created by this library
            </summary>
      <remarks>
            This is also the Zip version for the library when comparing against the version required to extract
            for an entry.  See <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CanDecompress" />.
            </remarks>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VERSION_MADE_BY">
      <summary>
            The version made by field for entries in the central header when created by this library
            </summary>
      <remarks>
            This is also the Zip version for the library when comparing against the version required to extract
            for an entry.  See <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipInputStream.CanDecompressEntry">ZipInputStream.CanDecompressEntry</see>.
            </remarks>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VersionStrongEncryption">
      <summary>
            The minimum version required to support strong encryption
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VERSION_STRONG_ENCRYPTION">
      <summary>
            The minimum version required to support strong encryption
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VERSION_AES">
      <summary>
            Version indicating AES encryption
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VersionZip64">
      <summary>
            The version required for Zip64 extensions (4.5 or higher)
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.LocalHeaderBaseSize">
      <summary>
            Size of local entry header (excluding variable length fields at end)
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.LOCHDR">
      <summary>
            Size of local entry header (excluding variable length fields at end)
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.Zip64DataDescriptorSize">
      <summary>
            Size of Zip64 data descriptor
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.DataDescriptorSize">
      <summary>
            Size of data descriptor
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.EXTHDR">
      <summary>
            Size of data descriptor
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CentralHeaderBaseSize">
      <summary>
            Size of central header entry (excluding variable fields)
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CENHDR">
      <summary>
            Size of central header entry
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.EndOfCentralRecordBaseSize">
      <summary>
            Size of end of central record (excluding variable fields)
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.ENDHDR">
      <summary>
            Size of end of central record (excluding variable fields)
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CryptoHeaderSize">
      <summary>
            Size of 'classic' cryptographic header stored before any entry data
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CRYPTO_HEADER_SIZE">
      <summary>
            Size of cryptographic header stored before entry data
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.LocalHeaderSignature">
      <summary>
            Signature for local entry header
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.LOCSIG">
      <summary>
            Signature for local entry header
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.SpanningSignature">
      <summary>
            Signature for spanning entry
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.SPANNINGSIG">
      <summary>
            Signature for spanning entry
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.SpanningTempSignature">
      <summary>
            Signature for temporary spanning entry
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.SPANTEMPSIG">
      <summary>
            Signature for temporary spanning entry
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.DataDescriptorSignature">
      <summary>
            Signature for data descriptor
            </summary>
      <remarks>
            This is only used where the length, Crc, or compressed size isnt known when the
            entry is created and the output stream doesnt support seeking.
            The local entry cannot be 'patched' with the correct values in this case
            so the values are recorded after the data prefixed by this header, as well as in the central directory.
            </remarks>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.EXTSIG">
      <summary>
            Signature for data descriptor
            </summary>
      <remarks>
            This is only used where the length, Crc, or compressed size isnt known when the
            entry is created and the output stream doesnt support seeking.
            The local entry cannot be 'patched' with the correct values in this case
            so the values are recorded after the data prefixed by this header, as well as in the central directory.
            </remarks>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CENSIG">
      <summary>
            Signature for central header
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CentralHeaderSignature">
      <summary>
            Signature for central header
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.Zip64CentralFileHeaderSignature">
      <summary>
            Signature for Zip64 central file header
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CENSIG64">
      <summary>
            Signature for Zip64 central file header
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.Zip64CentralDirLocatorSignature">
      <summary>
            Signature for Zip64 central directory locator
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.ArchiveExtraDataSignature">
      <summary>
            Signature for archive extra data signature (were headers are encrypted).
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CentralHeaderDigitalSignature">
      <summary>
            Central header digitial signature
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CENDIGITALSIG">
      <summary>
            Central header digitial signature
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.EndOfCentralDirectorySignature">
      <summary>
            End of central directory record signature
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.ENDSIG">
      <summary>
            End of central directory record signature
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToString(System.Byte[],System.Int32)">
      <summary>
            Convert a portion of a byte array to a string.
            </summary>
      <param name="data">
            Data to convert to string
            </param>
      <param name="count">
            Number of bytes to convert starting from index 0
            </param>
      <returns>
            data[0]..data[length - 1] converted to a string
            </returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToString(System.Byte[])">
      <summary>
            Convert a byte array to string
            </summary>
      <param name="data">
            Byte array to convert
            </param>
      <returns>
        <paramref name="data">data</paramref>converted to a string
            </returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[],System.Int32)">
      <summary>
            Convert a byte array to string
            </summary>
      <param name="flags">The applicable general purpose bits flags</param>
      <param name="data">
            Byte array to convert
            </param>
      <param name="count">The number of bytes to convert.</param>
      <returns>
        <paramref name="data">data</paramref>converted to a string
            </returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[])">
      <summary>
            Convert a byte array to string
            </summary>
      <param name="data">
            Byte array to convert
            </param>
      <param name="flags">The applicable general purpose bits flags</param>
      <returns>
        <paramref name="data">data</paramref>converted to a string
            </returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToArray(System.String)">
      <summary>
            Convert a string to a byte array
            </summary>
      <param name="str">
            String to convert to an array
            </param>
      <returns>Converted array</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToArray(System.Int32,System.String)">
      <summary>
            Convert a string to a byte array
            </summary>
      <param name="flags">The applicable <see cref="T:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags">general purpose bits flags</see></param>
      <param name="str">
            String to convert to an array
            </param>
      <returns>Converted array</returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipConstants.DefaultCodePage">
      <summary>
            Default encoding used for string conversion.  0 gives the default system OEM code page.
            Dont use unicode encodings if you want to be Zip compatible!
            Using the default code page isnt the full solution neccessarily
            there are many variable factors, codepage 850 is often a good choice for
            European users, however be careful about compatability.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.HostSystemID">
      <summary>
              Defines known values for the <see cref="T:ICSharpCode.SharpZipLib.Zip.HostSystemID" /> property.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Msdos">
      <summary>
              Host system = MSDOS
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Amiga">
      <summary>
              Host system = Amiga
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.OpenVms">
      <summary>
              Host system = Open VMS
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Unix">
      <summary>
              Host system = Unix
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.VMCms">
      <summary>
              Host system = VMCms
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.AtariST">
      <summary>
              Host system = Atari ST
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.OS2">
      <summary>
              Host system = OS2
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Macintosh">
      <summary>
              Host system = Macintosh
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.ZSystem">
      <summary>
              Host system = ZSystem
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Cpm">
      <summary>
              Host system = Cpm
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.WindowsNT">
      <summary>
              Host system = Windows NT
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.MVS">
      <summary>
              Host system = MVS
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Vse">
      <summary>
              Host system = VSE
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.AcornRisc">
      <summary>
              Host system = Acorn RISC
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Vfat">
      <summary>
              Host system = VFAT
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.AlternateMvs">
      <summary>
              Host system = Alternate MVS
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.BeOS">
      <summary>
              Host system = BEOS
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Tandem">
      <summary>
              Host system = Tandem
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.OS400">
      <summary>
              Host system = OS400
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.OSX">
      <summary>
              Host system = OSX
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.WinZipAES">
      <summary>
              Host system = WinZIP AES
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipEntry">
      <summary>
              This class represents an entry in a zip archive.  This can be a file
              or a directory
              ZipFile and ZipInputStream will give you instances of this class as 
              information about the members in an archive.  ZipOutputStream
              uses an instance of this class when creating an entry in a Zip file.
              <br /><br />Author of the original java version : Jochen Hoenicke
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.#ctor(System.String)">
      <summary>
              Creates a zip entry with the given name.
            </summary>
      <param name="name">
              The name for this entry. Can include directory components.
              The convention for names is 'unix' style paths with relative names only.
              There are with no device names and path elements are separated by '/' characters.
            </param>
      <exception cref="T:System.ArgumentNullException">
              The name passed is null
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.#ctor(ICSharpCode.SharpZipLib.Zip.ZipEntry)">
      <summary>
              Creates a deep copy of the given zip entry.
            </summary>
      <param name="entry">
              The entry to copy.
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.ForceZip64">
      <summary>
              Force this entry to be recorded using Zip64 extensions.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsZip64Forced">
      <summary>
              Get a value indicating wether Zip64 extensions were forced.
            </summary>
      <returns>A <see cref="T:System.Boolean" /> value of true if Zip64 extensions have been forced on; false if not.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported">
      <summary>
              Test entry to see if data can be extracted.
            </summary>
      <returns>Returns true if data can be extracted for this entry; false otherwise.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.Clone">
      <summary>
              Creates a copy of this zip entry.
            </summary>
      <returns>An <see cref="T:System.Object" /> that is a copy of the current instance.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.ToString">
      <summary>
              Gets a string representation of this ZipEntry.
            </summary>
      <returns>A readable textual representation of this <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /></returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported(ICSharpCode.SharpZipLib.Zip.CompressionMethod)">
      <summary>
              Test a <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CompressionMethod">compression method</see> to see if this library
              supports extracting data compressed with that method
            </summary>
      <param name="method">The compression method to test.</param>
      <returns>Returns true if the compression method is supported; false otherwise</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.CleanName(System.String)">
      <summary>
              Cleans a name making it conform to Zip file conventions.
              Devices names ('c:\') and UNC share names ('\\server\share') are removed
              and forward slashes ('\') are converted to back slashes ('/').
              Names are made relative by trimming leading slashes which is compatible
              with the ZIP naming convention.
            </summary>
      <param name="name">The name to clean</param>
      <returns>The 'cleaned' name.</returns>
      <remarks>
              The <seealso cref="T:ICSharpCode.SharpZipLib.Zip.ZipNameTransform">Zip name transform</seealso> class is more flexible.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.HasCrc">
      <summary>
              Get a value indicating wether the entry has a CRC value available.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCrypted">
      <summary>
              Get/Set flag indicating if entry is encrypted.
              A simple helper routine to aid interpretation of <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Flags">flags</see></summary>
      <remarks>
              This is an assistant that interprets the <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Flags">flags</see> property.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsUnicodeText">
      <summary>
              Get / set a flag indicating wether entry name and comment text are
              encoded in <a href="http://www.unicode.org">unicode UTF8</a>.
            </summary>
      <remarks>
              This is an assistant that interprets the <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Flags">flags</see> property.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CryptoCheckValue">
      <summary>
              Value used during password checking for PKZIP 2.0 / 'classic' encryption.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Flags">
      <summary>
              Get/Set general purpose bit flag for entry
            </summary>
      <remarks>
              General purpose bit flag<br /><br />
              Bit 0: If set, indicates the file is encrypted<br />
              Bit 1-2 Only used for compression type 6 Imploding, and 8, 9 deflating<br />
              Imploding:<br />
              Bit 1 if set indicates an 8K sliding dictionary was used.  If clear a 4k dictionary was used<br />
              Bit 2 if set indicates 3 Shannon-Fanno trees were used to encode the sliding dictionary, 2 otherwise<br /><br />
              Deflating:<br />
              Bit 2    Bit 1<br />
              0        0       Normal compression was used<br />
              0        1       Maximum compression was used<br />
              1        0       Fast compression was used<br />
              1        1       Super fast compression was used<br /><br />
              Bit 3: If set, the fields crc-32, compressed size
              and uncompressed size are were not able to be written during zip file creation
              The correct values are held in a data descriptor immediately following the compressed data. <br />
              Bit 4: Reserved for use by PKZIP for enhanced deflating<br />
              Bit 5: If set indicates the file contains compressed patch data<br />
              Bit 6: If set indicates strong encryption was used.<br />
              Bit 7-10: Unused or reserved<br />
              Bit 11: If set the name and comments for this entry are in <a href="http://www.unicode.org">unicode</a>.<br />
              Bit 12-15: Unused or reserved<br /></remarks>
      <seealso cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsUnicodeText">
      </seealso>
      <seealso cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCrypted">
      </seealso>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ZipFileIndex">
      <summary>
              Get/Set index of this entry in Zip file
            </summary>
      <remarks>
              This is only valid when the entry is part of a <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile"></see></remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Offset">
      <summary>
              Get/set offset for use in central header
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ExternalFileAttributes">
      <summary>
              Get/Set external file attributes as an integer.
              The values of this are operating system dependant see
              <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.HostSystem">HostSystem</see> for details
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.VersionMadeBy">
      <summary>
              Get the version made by for this entry or zero if unknown.
              The value / 10 indicates the major version number, and 
              the value mod 10 is the minor version number
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsDOSEntry">
      <summary>
              Get a value indicating this entry is for a DOS/Windows system.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.HostSystem">
      <summary>
              Gets the compatability information for the <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ExternalFileAttributes">external file attribute</see>
              If the external file attributes are compatible with MS-DOS and can be read
              by PKZIP for DOS version 2.04g then this value will be zero.  Otherwise the value
              will be non-zero and identify the host system on which the attributes are compatible.
            </summary>
      <remarks>
              The values for this as defined in the Zip File format and by others are shown below.  The values are somewhat
              misleading in some cases as they are not all used as shown.  You should consult the relevant documentation
              to obtain up to date and correct information.  The modified appnote by the infozip group is
              particularly helpful as it documents a lot of peculiarities.  The document is however a little dated.
              <list type="table"><item>0 - MS-DOS and OS/2 (FAT / VFAT / FAT32 file systems)</item><item>1 - Amiga</item><item>2 - OpenVMS</item><item>3 - Unix</item><item>4 - VM/CMS</item><item>5 - Atari ST</item><item>6 - OS/2 HPFS</item><item>7 - Macintosh</item><item>8 - Z-System</item><item>9 - CP/M</item><item>10 - Windows NTFS</item><item>11 - MVS (OS/390 - Z/OS)</item><item>12 - VSE</item><item>13 - Acorn Risc</item><item>14 - VFAT</item><item>15 - Alternate MVS</item><item>16 - BeOS</item><item>17 - Tandem</item><item>18 - OS/400</item><item>19 - OS/X (Darwin)</item><item>99 - WinZip AES</item><item>remainder - unused</item></list></remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Version">
      <summary>
              Get minimum Zip feature version required to extract this entry
            </summary>
      <remarks>
              Minimum features are defined as:<br />
              1.0 - Default value<br />
              1.1 - File is a volume label<br />
              2.0 - File is a folder/directory<br />
              2.0 - File is compressed using Deflate compression<br />
              2.0 - File is encrypted using traditional encryption<br />
              2.1 - File is compressed using Deflate64<br />
              2.5 - File is compressed using PKWARE DCL Implode<br />
              2.7 - File is a patch data set<br />
              4.5 - File uses Zip64 format extensions<br />
              4.6 - File is compressed using BZIP2 compression<br />
              5.0 - File is encrypted using DES<br />
              5.0 - File is encrypted using 3DES<br />
              5.0 - File is encrypted using original RC2 encryption<br />
              5.0 - File is encrypted using RC4 encryption<br />
              5.1 - File is encrypted using AES encryption<br />
              5.1 - File is encrypted using corrected RC2 encryption<br />
              5.1 - File is encrypted using corrected RC2-64 encryption<br />
              6.1 - File is encrypted using non-OAEP key wrapping<br />
              6.2 - Central directory encryption (not confirmed yet)<br />
              6.3 - File is compressed using LZMA<br />
              6.3 - File is compressed using PPMD+<br />
              6.3 - File is encrypted using Blowfish<br />
              6.3 - File is encrypted using Twofish<br /></remarks>
      <seealso cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CanDecompress">
      </seealso>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CanDecompress">
      <summary>
              Get a value indicating whether this entry can be decompressed by the library.
            </summary>
      <remarks>
              This is based on the <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Version"></see> and 
              wether the <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported">compression method</see> is supported.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.LocalHeaderRequiresZip64">
      <summary>
              Gets a value indicating if the entry requires Zip64 extensions 
              to store the full entry values.
            </summary>
      <value>A <see cref="T:System.Boolean" /> value of true if a local header requires Zip64 extensions; false if not.</value>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CentralHeaderRequiresZip64">
      <summary>
              Get a value indicating wether the central directory entry requires Zip64 extensions to be stored.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.DosTime">
      <summary>
              Get/Set DosTime value.
            </summary>
      <remarks>
              The MS-DOS date format can only represent dates between 1/1/1980 and 12/31/2107.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.DateTime">
      <summary>
              Gets/Sets the time of last modification of the entry.
            </summary>
      <remarks>
              The <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.DosTime"></see> property is updated to match this as far as possible.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Name">
      <summary>
              Returns the entry name.
            </summary>
      <remarks>
              The unix naming convention is followed.
              Path components in the entry should always separated by forward slashes ('/').
              Dos device names like C: should also be removed.
              See the <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipNameTransform" /> class, or <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.CleanName(System.String)" /></remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Size">
      <summary>
              Gets/Sets the size of the uncompressed data.
            </summary>
      <returns>
              The size or -1 if unknown.
            </returns>
      <remarks>
              Setting the size before adding an entry to an archive can help
              avoid compatability problems with some archivers which dont understand Zip64 extensions.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CompressedSize">
      <summary>
              Gets/Sets the size of the compressed data.
            </summary>
      <returns>
              The compressed entry size or -1 if unknown.
            </returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Crc">
      <summary>
              Gets/Sets the crc of the uncompressed data.
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">
              Crc is not in the range 0..0xffffffffL
            </exception>
      <returns>
              The crc value or -1 if unknown.
            </returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CompressionMethod">
      <summary>
              Gets/Sets the compression method. Only Deflated and Stored are supported.
            </summary>
      <returns>
              The compression method for this entry
            </returns>
      <see cref="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Deflated" />
      <see cref="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Stored" />
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CompressionMethodForHeader">
      <summary>
              Gets the compression method for outputting to the local or central header.
              Returns same value as CompressionMethod except when AES encrypting, which
              places 99 in the method and places the real method in the extra data.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ExtraData">
      <summary>
              Gets/Sets the extra data.
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">
              Extra data is longer than 64KB (0xffff) bytes.
            </exception>
      <returns>
              Extra data or null if not set.
            </returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.AESSaltLen">
      <summary>
              Returns the length of the salt, in bytes
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.AESOverheadSize">
      <summary>
              Number of extra bytes required to hold the AES Header fields (Salt, Pwd verify, AuthCode)
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Comment">
      <summary>
              Gets/Sets the entry comment.
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">
              If comment is longer than 0xffff.
            </exception>
      <returns>
              The comment or null if not set.
            </returns>
      <remarks>
              A comment is only available for entries when read via the <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile" /> class.
              The <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipInputStream" /> class doesnt have the comment data available.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsDirectory">
      <summary>
              Gets a value indicating if the entry is a directory.
              however.
            </summary>
      <remarks>
              A directory is determined by an entry name with a trailing slash '/'.
              The external file attributes can also indicate an entry is for a directory.
              Currently only dos/windows attributes are tested in this manner.
              The trailing slash convention should always be followed.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsFile">
      <summary>
              Get a value of true if the entry appears to be a file; false otherwise
            </summary>
      <remarks>
              This only takes account of DOS/Windows attributes.  Other operating systems are ignored.
              For linux and others the result may be incorrect.
            </remarks>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory">
      <summary>
            Basic implementation of <see cref="T:ICSharpCode.SharpZipLib.Zip.IEntryFactory"></see></summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.#ctor">
      <summary>
            Initialise a new instance of the <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory" /> class.
            </summary>
      <remarks>A default <see cref="T:ICSharpCode.SharpZipLib.Core.INameTransform" />, and the LastWriteTime for files is used.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.#ctor(ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory" /> using the specified <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting" /></summary>
      <param name="timeSetting">The <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting">time setting</see> to use when creating <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry">Zip entries</see>.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.#ctor(System.DateTime)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory" /> using the specified <see cref="T:System.DateTime" /></summary>
      <param name="time">The time to set all <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.DateTime" /> values to.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.MakeFileEntry(System.String)">
      <summary>
            Make a new <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> for a file.
            </summary>
      <param name="fileName">The name of the file to create a new entry for.</param>
      <returns>Returns a new <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> based on the <paramref name="fileName" />.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.MakeFileEntry(System.String,System.Boolean)">
      <summary>
            Make a new <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> from a name.
            </summary>
      <param name="fileName">The name of the file to create a new entry for.</param>
      <param name="useFileSystem">If true entry detail is retrieved from the file system if the file exists.</param>
      <returns>Returns a new <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> based on the <paramref name="fileName" />.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.MakeDirectoryEntry(System.String)">
      <summary>
            Make a new <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry"></see> for a directory.
            </summary>
      <param name="directoryName">The raw untransformed name for the new directory</param>
      <returns>Returns a new <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry"></see> representing a directory.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.MakeDirectoryEntry(System.String,System.Boolean)">
      <summary>
            Make a new <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry"></see> for a directory.
            </summary>
      <param name="directoryName">The raw untransformed name for the new directory</param>
      <param name="useFileSystem">If true entry detail is retrieved from the file system if the file exists.</param>
      <returns>Returns a new <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry"></see> representing a directory.</returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.NameTransform">
      <summary>
            Get / set the <see cref="T:ICSharpCode.SharpZipLib.Core.INameTransform" /> to be used when creating new <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> values.
            </summary>
      <remarks>
            Setting this property to null will cause a default <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipNameTransform">name transform</see> to be used.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.Setting">
      <summary>
            Get / set the <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting" /> in use.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.FixedDateTime">
      <summary>
            Get / set the <see cref="T:System.DateTime" /> value to use when <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.Setting" /> is set to <see cref="F:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.Fixed" /></summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.GetAttributes">
      <summary>
            A bitmask defining the attributes to be retrieved from the actual file.
            </summary>
      <remarks>The default is to get all possible attributes from the actual file.</remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.SetAttributes">
      <summary>
            A bitmask defining which attributes are to be set on.
            </summary>
      <remarks>By default no attributes are set on.</remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.IsUnicodeText">
      <summary>
            Get set a value indicating wether unidoce text should be set on.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting">
      <summary>
            Defines the possible values to be used for the <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.DateTime" />.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.LastWriteTime">
      <summary>
            Use the recorded LastWriteTime value for the file.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.LastWriteTimeUtc">
      <summary>
            Use the recorded LastWriteTimeUtc value for the file
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.CreateTime">
      <summary>
            Use the recorded CreateTime value for the file.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.CreateTimeUtc">
      <summary>
            Use the recorded CreateTimeUtc value for the file.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.LastAccessTime">
      <summary>
            Use the recorded LastAccessTime value for the file.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.LastAccessTimeUtc">
      <summary>
            Use the recorded LastAccessTimeUtc value for the file.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.Fixed">
      <summary>
            Use a fixed value.
            </summary>
      <remarks>The actual <see cref="T:System.DateTime" /> value used can be
            specified via the <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.#ctor(System.DateTime)" /> constructor or 
            using the <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.#ctor(ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting)" /> with the setting set
            to <see cref="F:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.Fixed" /> which will use the <see cref="T:System.DateTime" /> when this class was constructed.
            The <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntryFactory.FixedDateTime" /> property can also be used to set this value.</remarks>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipException">
      <summary>
            Represents exception conditions specific to Zip archive handling
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipException.#ctor">
      <summary>
            Initializes a new instance of the ZipException class.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the ZipException class with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipException.#ctor(System.String,System.Exception)">
      <summary>
            Initialise a new instance of ZipException.
            </summary>
      <param name="message">A message describing the error.</param>
      <param name="exception">The exception that is the cause of the current exception.</param>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">
      <summary>
            ExtraData tagged value interface.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ITaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Set the contents of this instance from the data passed.
            </summary>
      <param name="data">The data to extract contents from.</param>
      <param name="offset">The offset to begin extracting data from.</param>
      <param name="count">The number of bytes to extract.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ITaggedData.GetData">
      <summary>
            Get the data representing this instance.
            </summary>
      <returns>Returns the data for this instance.</returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ITaggedData.TagID">
      <summary>
            Get the ID for this tagged data value.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.RawTaggedData">
      <summary>
            A raw binary tagged value
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.RawTaggedData.#ctor(System.Int16)">
      <summary>
            Initialise a new instance.
            </summary>
      <param name="tag">The tag ID.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.RawTaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Set the data from the raw values provided.
            </summary>
      <param name="data">The raw data to extract values from.</param>
      <param name="offset">The index to start extracting values from.</param>
      <param name="count">The number of bytes available.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.RawTaggedData.GetData">
      <summary>
            Get the binary data representing this instance.
            </summary>
      <returns>The raw binary data representing this instance.</returns>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.RawTaggedData.TagID">
      <summary>
            Get the ID for this tagged data value.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.RawTaggedData.Data">
      <summary>
            Get /set the binary data representing this instance.
            </summary>
      <returns>The raw binary data representing this instance.</returns>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData">
      <summary>
            Class representing extended unix date time values.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.SetData(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Set the data from the raw values provided.
            </summary>
      <param name="data">The raw data to extract values from.</param>
      <param name="index">The index to start extracting values from.</param>
      <param name="count">The number of bytes available.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.GetData">
      <summary>
            Get the binary data representing this instance.
            </summary>
      <returns>The raw binary data representing this instance.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)">
      <summary>
            Test a <see cref="T:System.DateTime"> value to see if is valid and can be represented here.</see></summary>
      <param name="value">The <see cref="T:System.DateTime">value</see> to test.</param>
      <returns>Returns true if the value is valid and can be represented; false if not.</returns>
      <remarks>The standard Unix time is a signed integer data type, directly encoding the Unix time number,
            which is the number of seconds since 1970-01-01.
            Being 32 bits means the values here cover a range of about 136 years.
            The minimum representable time is 1901-12-13 20:45:52,
            and the maximum representable time is 2038-01-19 03:14:07.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.TagID">
      <summary>
            Get the ID
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.ModificationTime">
      <summary>
            Get /set the Modification Time
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">
      </exception>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)">
      </seealso>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.AccessTime">
      <summary>
            Get / set the Access Time
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">
      </exception>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)">
      </seealso>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.CreateTime">
      <summary>
            Get / Set the Create Time
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">
      </exception>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)">
      </seealso>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Include">
      <summary>
            Get/set the <see cref="T:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags">values</see> to include.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags">
      <summary>
            Flags indicate which values are included in this instance.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags.ModificationTime">
      <summary>
            The modification time is included
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags.AccessTime">
      <summary>
            The access time is included
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags.CreateTime">
      <summary>
            The create time is included.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.NTTaggedData">
      <summary>
            Class handling NT date time values.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.NTTaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Set the data from the raw values provided.
            </summary>
      <param name="data">The raw data to extract values from.</param>
      <param name="index">The index to start extracting values from.</param>
      <param name="count">The number of bytes available.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.NTTaggedData.GetData">
      <summary>
            Get the binary data representing this instance.
            </summary>
      <returns>The raw binary data representing this instance.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.NTTaggedData.IsValidValue(System.DateTime)">
      <summary>
            Test a <see cref="T:System.DateTime"> valuie to see if is valid and can be represented here.</see></summary>
      <param name="value">The <see cref="T:System.DateTime">value</see> to test.</param>
      <returns>Returns true if the value is valid and can be represented; false if not.</returns>
      <remarks>
            NTFS filetimes are 64-bit unsigned integers, stored in Intel
            (least significant byte first) byte order. They determine the
            number of 1.0E-07 seconds (1/10th microseconds!) past WinNT "epoch",
            which is "01-Jan-1601 00:00:00 UTC". 28 May 60056 is the upper limit
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.NTTaggedData.TagID">
      <summary>
            Get the ID for this tagged data value.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.NTTaggedData.LastModificationTime">
      <summary>
            Get/set the <see cref="T:System.DateTime">last modification time</see>.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.NTTaggedData.CreateTime">
      <summary>
            Get /set the <see cref="T:System.DateTime">create time</see></summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.NTTaggedData.LastAccessTime">
      <summary>
            Get /set the <see cref="T:System.DateTime">last access time</see>.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ITaggedDataFactory">
      <summary>
            A factory that creates <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">tagged data</see> instances.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ITaggedDataFactory.Create(System.Int16,System.Byte[],System.Int32,System.Int32)">
      <summary>
            Get data for a specific tag value.
            </summary>
      <param name="tag">The tag ID to find.</param>
      <param name="data">The data to search.</param>
      <param name="offset">The offset to begin extracting data from.</param>
      <param name="count">The number of bytes to extract.</param>
      <returns>The located <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">value found</see>, or null if not found.</returns>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipExtraData">
      <summary>
            A class to handle the extra data field for Zip entries
            </summary>
      <remarks>
            Extra data contains 0 or more values each prefixed by a header tag and length.
            They contain zero or more bytes of actual data.
            The data is held internally using a copy on write strategy.  This is more efficient but
            means that for extra data created by passing in data can have the values modified by the caller
            in some circumstances.
            </remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.#ctor">
      <summary>
            Initialise a default instance.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.#ctor(System.Byte[])">
      <summary>
            Initialise with known extra data.
            </summary>
      <param name="data">The extra data.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.GetEntryData">
      <summary>
            Get the raw extra data value
            </summary>
      <returns>Returns the raw byte[] extra data this instance represents.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Clear">
      <summary>
            Clear the stored data.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.GetStreamForTag(System.Int32)">
      <summary>
            Get a read-only <see cref="T:System.IO.Stream" /> for the associated tag.
            </summary>
      <param name="tag">The tag to locate data for.</param>
      <returns>Returns a <see cref="T:System.IO.Stream" /> containing tag data or null if no tag was found.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.GetData(System.Int16)">
      <summary>
            Get the <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">tagged data</see> for a tag.
            </summary>
      <param name="tag">The tag to search for.</param>
      <returns>Returns a <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">tagged value</see> or null if none found.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">
      <summary>
            Find an extra data value
            </summary>
      <param name="headerID">The identifier for the value to find.</param>
      <returns>Returns true if the value was found; false otherwise.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddEntry(ICSharpCode.SharpZipLib.Zip.ITaggedData)">
      <summary>
            Add a new entry to extra data.
            </summary>
      <param name="taggedData">The <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData" /> value to add.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddEntry(System.Int32,System.Byte[])">
      <summary>
            Add a new entry to extra data
            </summary>
      <param name="headerID">The ID for this entry.</param>
      <param name="fieldData">The data to add.</param>
      <remarks>If the ID already exists its contents are replaced.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry">
      <summary>
            Start adding a new entry.
            </summary>
      <remarks>Add data using <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte[])" />, <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeShort(System.Int32)" />, <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeInt(System.Int32)" />, or <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeLong(System.Int64)" />.
            The new entry is completed and actually added by calling <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddNewEntry(System.Int32)" /></remarks>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddEntry(ICSharpCode.SharpZipLib.Zip.ITaggedData)" />
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddNewEntry(System.Int32)">
      <summary>
            Add entry data added since <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry" /> using the ID passed.
            </summary>
      <param name="headerID">The identifier to use for this entry.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte)">
      <summary>
            Add a byte of data to the pending new entry.
            </summary>
      <param name="data">The byte to add.</param>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry" />
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte[])">
      <summary>
            Add data to a pending new entry.
            </summary>
      <param name="data">The data to add.</param>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry" />
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeShort(System.Int32)">
      <summary>
            Add a short value in little endian order to the pending new entry.
            </summary>
      <param name="toAdd">The data to add.</param>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry" />
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeInt(System.Int32)">
      <summary>
            Add an integer value in little endian order to the pending new entry.
            </summary>
      <param name="toAdd">The data to add.</param>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry" />
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeLong(System.Int64)">
      <summary>
            Add a long value in little endian order to the pending new entry.
            </summary>
      <param name="toAdd">The data to add.</param>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry" />
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Delete(System.Int32)">
      <summary>
            Delete an extra data field.
            </summary>
      <param name="headerID">The identifier of the field to delete.</param>
      <returns>Returns true if the field was found and deleted.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadLong">
      <summary>
            Read a long in little endian form from the last <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value
            </summary>
      <returns>Returns the long value read.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadInt">
      <summary>
            Read an integer in little endian form from the last <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value.
            </summary>
      <returns>Returns the integer read.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadShort">
      <summary>
            Read a short value in little endian form from the last <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value.
            </summary>
      <returns>Returns the short value read.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadByte">
      <summary>
            Read a byte from an extra data
            </summary>
      <returns>The byte value read or -1 if the end of data has been reached.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Skip(System.Int32)">
      <summary>
            Skip data during reading.
            </summary>
      <param name="amount">The number of bytes to skip.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Dispose">
      <summary>
            Dispose of this instance.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Length">
      <summary>
            Gets the current extra data length.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ValueLength">
      <summary>
            Get the length of the last value found by <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)" /></summary>
      <remarks>This is only valid if <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)" /> has previously returned true.</remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.CurrentReadIndex">
      <summary>
            Get the index for the current read value.
            </summary>
      <remarks>This is only valid if <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)" /> has previously returned true.
            Initially the result will be the index of the first byte of actual data.  The value is updated after calls to
            <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadInt" />, <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadShort" /> and <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadLong" />. </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.UnreadCount">
      <summary>
            Get the number of bytes remaining to be read for the current value;
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.KeysRequiredEventArgs">
      <summary>
            Arguments used with KeysRequiredEvent
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.KeysRequiredEventArgs.#ctor(System.String)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.KeysRequiredEventArgs"></see></summary>
      <param name="name">The name of the file for which keys are required.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.KeysRequiredEventArgs.#ctor(System.String,System.Byte[])">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.KeysRequiredEventArgs"></see></summary>
      <param name="name">The name of the file for which keys are required.</param>
      <param name="keyValue">The current key value.</param>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.KeysRequiredEventArgs.FileName">
      <summary>
            Gets the name of the file for which keys are required.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.KeysRequiredEventArgs.Key">
      <summary>
            Gets or sets the key value
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.TestStrategy">
      <summary>
            The strategy to apply to testing.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.TestStrategy.FindFirstError">
      <summary>
            Find the first error only.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.TestStrategy.FindAllErrors">
      <summary>
            Find all possible errors.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.TestOperation">
      <summary>
            The operation in progress reported by a <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipTestResultHandler" /> during testing.
            </summary>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean)">TestArchive</seealso>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.TestOperation.Initialising">
      <summary>
            Setting up testing.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.TestOperation.EntryHeader">
      <summary>
            Testing an individual entries header
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.TestOperation.EntryData">
      <summary>
            Testing an individual entries data
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.TestOperation.EntryComplete">
      <summary>
            Testing an individual entry has completed.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.TestOperation.MiscellaneousTests">
      <summary>
            Running miscellaneous tests
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.TestOperation.Complete">
      <summary>
            Testing is complete
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.TestStatus">
      <summary>
            Status returned returned by <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipTestResultHandler" /> during testing.
            </summary>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean)">TestArchive</seealso>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.TestStatus.#ctor(ICSharpCode.SharpZipLib.Zip.ZipFile)">
      <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.TestStatus" /></summary>
      <param name="file">The <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile" /> this status applies to.</param>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.TestStatus.Operation">
      <summary>
            Get the current <see cref="T:ICSharpCode.SharpZipLib.Zip.TestOperation" /> in progress.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.TestStatus.File">
      <summary>
            Get the <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile" /> this status is applicable to.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.TestStatus.Entry">
      <summary>
            Get the current/last entry tested.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.TestStatus.ErrorCount">
      <summary>
            Get the number of errors detected so far.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.TestStatus.BytesTested">
      <summary>
            Get the number of bytes tested so far for the current entry.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.TestStatus.EntryValid">
      <summary>
            Get a value indicating wether the last entry test was valid.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipTestResultHandler">
      <summary>
            Delegate invoked during <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean,ICSharpCode.SharpZipLib.Zip.TestStrategy,ICSharpCode.SharpZipLib.Zip.ZipTestResultHandler)">testing</see> if supplied indicating current progress and status.
            </summary>
      <remarks>If the message is non-null an error has occured.  If the message is null
            the operation as found in <see cref="T:ICSharpCode.SharpZipLib.Zip.TestStatus">status</see> has started.</remarks>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.FileUpdateMode">
      <summary>
            The possible ways of <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipFile.CommitUpdate">applying updates</see> to an archive.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.FileUpdateMode.Safe">
      <summary>
            Perform all updates on temporary files ensuring that the original file is saved.
            </summary>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.FileUpdateMode.Direct">
      <summary>
            Update the archive directly, which is faster but less safe.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipFile">
      <summary>
            This class represents a Zip archive.  You can ask for the contained
            entries, or get an input stream for a file entry.  The entry is
            automatically decompressed.
            
            You can also update the archive adding or deleting entries.
            
            This class is thread safe for input:  You can open input streams for arbitrary
            entries in different threads.
            <br /><br />Author of the original java version : Jochen Hoenicke
            </summary>
      <example>
        <code>
            using System;
            using System.Text;
            using System.Collections;
            using System.IO;
            
            using ICSharpCode.SharpZipLib.Zip;
            
            class MainClass
            {
            	static public void Main(string[] args)
            	{
            		using (ZipFile zFile = new ZipFile(args[0])) {
            			Console.WriteLine("Listing of : " + zFile.Name);
            			Console.WriteLine("");
            			Console.WriteLine("Raw Size    Size      Date     Time     Name");
            			Console.WriteLine("--------  --------  --------  ------  ---------");
            			foreach (ZipEntry e in zFile) {
            				if ( e.IsFile ) {
            					DateTime d = e.DateTime;
            					Console.WriteLine("{0, -10}{1, -10}{2}  {3}   {4}", e.Size, e.CompressedSize,
            						d.ToString("dd-MM-yy"), d.ToString("HH:mm"),
            						e.Name);
            				}
            			}
            		}
            	}
            }
            </code>
      </example>
    </member>
    <member name="F:ICSharpCode.SharpZipLib.Zip.ZipFile.KeysRequired">
      <summary>
            Event handler for handling encryption keys.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.#ctor(System.String)">
      <summary>
            Opens a Zip file with the given name for reading.
            </summary>
      <param name="name">The name of the file to open.</param>
      <exception cref="T:System.ArgumentNullException">The argument supplied is null.</exception>
      <exception cref="T:System.IO.IOException">
            An i/o error occurs
            </exception>
      <exception cref="T:ICSharpCode.SharpZipLib.Zip.ZipException">
            The file doesn't contain a valid zip archive.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.#ctor(System.IO.FileStream)">
      <summary>
            Opens a Zip file reading the given <see cref="T:System.IO.FileStream" />.
            </summary>
      <param name="file">The <see cref="T:System.IO.FileStream" /> to read archive data from.</param>
      <exception cref="T:System.ArgumentNullException">The supplied argument is null.</exception>
      <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
      <exception cref="T:ICSharpCode.SharpZipLib.Zip.ZipException">
            The file doesn't contain a valid zip archive.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.#ctor(System.IO.Stream)">
      <summary>
            Opens a Zip file reading the given <see cref="T:System.IO.Stream" />.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to read archive data from.</param>
      <exception cref="T:System.IO.IOException">
            An i/o error occurs
            </exception>
      <exception cref="T:ICSharpCode.SharpZipLib.Zip.ZipException">
            The stream doesn't contain a valid zip archive.<br /></exception>
      <exception cref="T:System.ArgumentException">
            The <see cref="T:System.IO.Stream">stream</see> doesnt support seeking.
            </exception>
      <exception cref="T:System.ArgumentNullException">
            The <see cref="T:System.IO.Stream">stream</see> argument is null.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Finalize">
      <summary>
            Finalize this instance.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Close">
      <summary>
            Closes the ZipFile.  If the stream is <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipFile.IsStreamOwner">owned</see> then this also closes the underlying input stream.
            Once closed, no further instance methods should be called.
            </summary>
      <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Create(System.String)">
      <summary>
            Create a new <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile" /> whose data will be stored in a file.
            </summary>
      <param name="fileName">The name of the archive to create.</param>
      <returns>Returns the newly created <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile" /></returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fileName">
        </paramref> is null</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Create(System.IO.Stream)">
      <summary>
            Create a new <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile" /> whose data will be stored on a stream.
            </summary>
      <param name="outStream">The stream providing data storage.</param>
      <returns>Returns the newly created <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile" /></returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outStream"> is null</paramref>
      </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="outStream"> doesnt support writing.</paramref>
      </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.GetEnumerator">
      <summary>
            Gets an enumerator for the Zip entries in this Zip file.
            </summary>
      <returns>Returns an <see cref="T:System.Collections.IEnumerator" /> for this archive.</returns>
      <exception cref="T:System.ObjectDisposedException">
            The Zip file has been closed.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.FindEntry(System.String,System.Boolean)">
      <summary>
            Return the index of the entry with a matching name
            </summary>
      <param name="name">Entry name to find</param>
      <param name="ignoreCase">If true the comparison is case insensitive</param>
      <returns>The index position of the matching entry or -1 if not found</returns>
      <exception cref="T:System.ObjectDisposedException">
            The Zip file has been closed.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.GetEntry(System.String)">
      <summary>
            Searches for a zip entry in this archive with the given name.
            String comparisons are case insensitive
            </summary>
      <param name="name">
            The name to find. May contain directory components separated by slashes ('/').
            </param>
      <returns>
            A clone of the zip entry, or null if no entry with that name exists.
            </returns>
      <exception cref="T:System.ObjectDisposedException">
            The Zip file has been closed.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.GetInputStream(ICSharpCode.SharpZipLib.Zip.ZipEntry)">
      <summary>
            Gets an input stream for reading the given zip entry data in an uncompressed form.
            Normally the <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> should be an entry returned by GetEntry().
            </summary>
      <param name="entry">The <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> to obtain a data <see cref="T:System.IO.Stream" /> for</param>
      <returns>An input <see cref="T:System.IO.Stream" /> containing data for this <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /></returns>
      <exception cref="T:System.ObjectDisposedException">
            The ZipFile has already been closed
            </exception>
      <exception cref="T:ICSharpCode.SharpZipLib.Zip.ZipException">
            The compression method for the entry is unknown
            </exception>
      <exception cref="T:System.IndexOutOfRangeException">
            The entry is not found in the ZipFile
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.GetInputStream(System.Int64)">
      <summary>
            Creates an input stream reading a zip entry
            </summary>
      <param name="entryIndex">The index of the entry to obtain an input stream for.</param>
      <returns>
            An input <see cref="T:System.IO.Stream" /> containing data for this <paramref name="entryIndex" /></returns>
      <exception cref="T:System.ObjectDisposedException">
            The ZipFile has already been closed
            </exception>
      <exception cref="T:ICSharpCode.SharpZipLib.Zip.ZipException">
            The compression method for the entry is unknown
            </exception>
      <exception cref="T:System.IndexOutOfRangeException">
            The entry is not found in the ZipFile
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean)">
      <summary>
            Test an archive for integrity/validity
            </summary>
      <param name="testData">Perform low level data Crc check</param>
      <returns>true if all tests pass, false otherwise</returns>
      <remarks>Testing will terminate on the first error found.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean,ICSharpCode.SharpZipLib.Zip.TestStrategy,ICSharpCode.SharpZipLib.Zip.ZipTestResultHandler)">
      <summary>
            Test an archive for integrity/validity
            </summary>
      <param name="testData">Perform low level data Crc check</param>
      <param name="strategy">The <see cref="T:ICSharpCode.SharpZipLib.Zip.TestStrategy"></see> to apply.</param>
      <param name="resultHandler">The <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipTestResultHandler"></see> handler to call during testing.</param>
      <returns>true if all tests pass, false otherwise</returns>
      <exception cref="T:System.ObjectDisposedException">The object has already been closed.</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.BeginUpdate(ICSharpCode.SharpZipLib.Zip.IArchiveStorage,ICSharpCode.SharpZipLib.Zip.IDynamicDataSource)">
      <summary>
            Begin updating this <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile" /> archive.
            </summary>
      <param name="archiveStorage">The <see cref="T:ICSharpCode.SharpZipLib.Zip.IArchiveStorage">archive storage</see> for use during the update.</param>
      <param name="dataSource">The <see cref="T:ICSharpCode.SharpZipLib.Zip.IDynamicDataSource">data source</see> to utilise during updating.</param>
      <exception cref="T:System.ObjectDisposedException">ZipFile has been closed.</exception>
      <exception cref="T:System.ArgumentNullException">One of the arguments provided is null</exception>
      <exception cref="T:System.ObjectDisposedException">ZipFile has been closed.</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.BeginUpdate(ICSharpCode.SharpZipLib.Zip.IArchiveStorage)">
      <summary>
            Begin updating to this <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile" /> archive.
            </summary>
      <param name="archiveStorage">The storage to use during the update.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.BeginUpdate">
      <summary>
            Begin updating this <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile" /> archive.
            </summary>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipFile.BeginUpdate(ICSharpCode.SharpZipLib.Zip.IArchiveStorage)" />
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipFile.CommitUpdate">
      </seealso>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipFile.AbortUpdate">
      </seealso>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.CommitUpdate">
      <summary>
            Commit current updates, updating this archive.
            </summary>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipFile.BeginUpdate">
      </seealso>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipFile.AbortUpdate">
      </seealso>
      <exception cref="T:System.ObjectDisposedException">ZipFile has been closed.</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.AbortUpdate">
      <summary>
            Abort updating leaving the archive unchanged.
            </summary>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipFile.BeginUpdate">
      </seealso>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipFile.CommitUpdate">
      </seealso>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.SetComment(System.String)">
      <summary>
            Set the file comment to be recorded when the current update is <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipFile.CommitUpdate">commited</see>.
            </summary>
      <param name="comment">The comment to record.</param>
      <exception cref="T:System.ObjectDisposedException">ZipFile has been closed.</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(System.String,ICSharpCode.SharpZipLib.Zip.CompressionMethod,System.Boolean)">
      <summary>
            Add a new entry to the archive.
            </summary>
      <param name="fileName">The name of the file to add.</param>
      <param name="compressionMethod">The compression method to use.</param>
      <param name="useUnicodeText">Ensure Unicode text is used for name and comment for this entry.</param>
      <exception cref="T:System.ArgumentNullException">Argument supplied is null.</exception>
      <exception cref="T:System.ObjectDisposedException">ZipFile has been closed.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Compression method is not supported.</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(System.String,ICSharpCode.SharpZipLib.Zip.CompressionMethod)">
      <summary>
            Add a new entry to the archive.
            </summary>
      <param name="fileName">The name of the file to add.</param>
      <param name="compressionMethod">The compression method to use.</param>
      <exception cref="T:System.ArgumentNullException">ZipFile has been closed.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The compression method is not supported.</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(System.String)">
      <summary>
            Add a file to the archive.
            </summary>
      <param name="fileName">The name of the file to add.</param>
      <exception cref="T:System.ArgumentNullException">Argument supplied is null.</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(System.String,System.String)">
      <summary>
            Add a file to the archive.
            </summary>
      <param name="fileName">The name of the file to add.</param>
      <param name="entryName">The name to use for the <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> on the Zip file created.</param>
      <exception cref="T:System.ArgumentNullException">Argument supplied is null.</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(ICSharpCode.SharpZipLib.Zip.IStaticDataSource,System.String)">
      <summary>
            Add a file entry with data.
            </summary>
      <param name="dataSource">The source of the data for this entry.</param>
      <param name="entryName">The name to give to the entry.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(ICSharpCode.SharpZipLib.Zip.IStaticDataSource,System.String,ICSharpCode.SharpZipLib.Zip.CompressionMethod)">
      <summary>
            Add a file entry with data.
            </summary>
      <param name="dataSource">The source of the data for this entry.</param>
      <param name="entryName">The name to give to the entry.</param>
      <param name="compressionMethod">The compression method to use.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(ICSharpCode.SharpZipLib.Zip.IStaticDataSource,System.String,ICSharpCode.SharpZipLib.Zip.CompressionMethod,System.Boolean)">
      <summary>
            Add a file entry with data.
            </summary>
      <param name="dataSource">The source of the data for this entry.</param>
      <param name="entryName">The name to give to the entry.</param>
      <param name="compressionMethod">The compression method to use.</param>
      <param name="useUnicodeText">Ensure Unicode text is used for name and comments for this entry.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(ICSharpCode.SharpZipLib.Zip.ZipEntry)">
      <summary>
            Add a <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> that contains no data.
            </summary>
      <param name="entry">The entry to add.</param>
      <remarks>This can be used to add directories, volume labels, or empty file entries.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.AddDirectory(System.String)">
      <summary>
            Add a directory entry to the archive.
            </summary>
      <param name="directoryName">The directory to add.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Delete(System.String)">
      <summary>
            Delete an entry by name
            </summary>
      <param name="fileName">The filename to delete</param>
      <returns>True if the entry was found and deleted; false otherwise.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Delete(ICSharpCode.SharpZipLib.Zip.ZipEntry)">
      <summary>
            Delete a <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> from the archive.
            </summary>
      <param name="entry">The entry to delete.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Dispose(System.Boolean)">
      <summary>
            Releases the unmanaged resources used by the this instance and optionally releases the managed resources.
            </summary>
      <param name="disposing">true to release both managed and unmanaged resources;
            false to release only unmanaged resources.</param>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.Key">
      <summary>
            Get/set the encryption key value.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.Password">
      <summary>
            Password to be used for encrypting/decrypting files.
            </summary>
      <remarks>Set to null if no password is required.</remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.HaveKeys">
      <summary>
            Get a value indicating wether encryption keys are currently available.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.IsStreamOwner">
      <summary>
            Get/set a flag indicating if the underlying stream is owned by the ZipFile instance.
            If the flag is true then the stream will be closed when <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Close">Close</see> is called.
            </summary>
      <remarks>
            The default value is true in all cases.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.IsEmbeddedArchive">
      <summary>
            Get a value indicating wether
            this archive is embedded in another file or not.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.IsNewArchive">
      <summary>
            Get a value indicating that this archive is a new one.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.ZipFileComment">
      <summary>
            Gets the comment for the zip file.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.Name">
      <summary>
            Gets the name of this zip file.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.Size">
      <summary>
            Gets the number of entries in this zip file.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            The Zip file has been closed.
            </exception>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.Count">
      <summary>
            Get the number of entries contained in this <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile" />.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.EntryByIndex(System.Int32)">
      <summary>
            Indexer property for ZipEntries
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.NameTransform">
      <summary>
            Get / set the <see cref="T:ICSharpCode.SharpZipLib.Core.INameTransform" /> to apply to names when updating.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.EntryFactory">
      <summary>
            Get/set the <see cref="T:ICSharpCode.SharpZipLib.Zip.IEntryFactory" /> used to generate <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> values
            during updates.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.BufferSize">
      <summary>
            Get /set the buffer size to be used when updating this zip file.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.IsUpdating">
      <summary>
            Get a value indicating an update has <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipFile.BeginUpdate">been started</see>.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.UseZip64">
      <summary>
            Get / set a value indicating how Zip64 Extension usage is determined when adding entries.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipFile.KeysRequiredEventHandler">
      <summary>
            Delegate for handling keys/password setting during compresion/decompression.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipFile.UpdateComparer">
      <summary>
            Class used to sort updates.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.UpdateComparer.Compare(System.Object,System.Object)">
      <summary>
            Compares two objects and returns a value indicating whether one is 
            less than, equal to or greater than the other.
            </summary>
      <param name="x">First object to compare</param>
      <param name="y">Second object to compare.</param>
      <returns>Compare result.</returns>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.IStaticDataSource">
      <summary>
            Provides a static way to obtain a source of data for an entry.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IStaticDataSource.GetSource">
      <summary>
            Get a source of data by creating a new stream.
            </summary>
      <returns>Returns a <see cref="T:System.IO.Stream" /> to use for compression input.</returns>
      <remarks>Ideally a new stream is created and opened to achieve this, to avoid locking problems.</remarks>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.IDynamicDataSource">
      <summary>
            Represents a source of data that can dynamically provide
            multiple <see cref="T:System.IO.Stream">data sources</see> based on the parameters passed.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IDynamicDataSource.GetSource(ICSharpCode.SharpZipLib.Zip.ZipEntry,System.String)">
      <summary>
            Get a data source.
            </summary>
      <param name="entry">The <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry" /> to get a source for.</param>
      <param name="name">The name for data if known.</param>
      <returns>Returns a <see cref="T:System.IO.Stream" /> to use for compression input.</returns>
      <remarks>Ideally a new stream is created and opened to achieve this, to avoid locking problems.</remarks>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.StaticDiskDataSource">
      <summary>
            Default implementation of a <see cref="T:ICSharpCode.SharpZipLib.Zip.IStaticDataSource" /> for use with files stored on disk.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.StaticDiskDataSource.#ctor(System.String)">
      <summary>
            Initialise a new instnace of <see cref="T:ICSharpCode.SharpZipLib.Zip.StaticDiskDataSource" /></summary>
      <param name="fileName">The name of the file to obtain data from.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.StaticDiskDataSource.GetSource">
      <summary>
            Get a <see cref="T:System.IO.Stream" /> providing data.
            </summary>
      <returns>Returns a <see cref="T:System.IO.Stream" /> provising data.</returns>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.DynamicDiskDataSource">
      <summary>
            Default implementation of <see cref="T:ICSharpCode.SharpZipLib.Zip.IDynamicDataSource" /> for files stored on disk.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DynamicDiskDataSource.#ctor">
      <summary>
            Initialise a default instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.DynamicDiskDataSource" />.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DynamicDiskDataSource.GetSource(ICSharpCode.SharpZipLib.Zip.ZipEntry,System.String)">
      <summary>
            Get a <see cref="T:System.IO.Stream" /> providing data for an entry.
            </summary>
      <param name="entry">The entry to provide data for.</param>
      <param name="name">The file name for data if known.</param>
      <returns>Returns a stream providing data; or null if not available</returns>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.IArchiveStorage">
      <summary>
            Defines facilities for data storage when updating Zip Archives.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IArchiveStorage.GetTemporaryOutput">
      <summary>
            Get an empty <see cref="T:System.IO.Stream" /> that can be used for temporary output.
            </summary>
      <returns>Returns a temporary output <see cref="T:System.IO.Stream" /></returns>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.IArchiveStorage.ConvertTemporaryToFinal">
      </seealso>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IArchiveStorage.ConvertTemporaryToFinal">
      <summary>
            Convert a temporary output stream to a final stream.
            </summary>
      <returns>The resulting final <see cref="T:System.IO.Stream" /></returns>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.IArchiveStorage.GetTemporaryOutput" />
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
      <summary>
            Make a temporary copy of the original stream.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to copy.</param>
      <returns>Returns a temporary output <see cref="T:System.IO.Stream" /> that is a copy of the input.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
      <summary>
            Return a stream suitable for performing direct updates on the original source.
            </summary>
      <param name="stream">The current stream.</param>
      <returns>Returns a stream suitable for direct updating.</returns>
      <remarks>This may be the current stream passed.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IArchiveStorage.Dispose">
      <summary>
            Dispose of this instance.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.IArchiveStorage.UpdateMode">
      <summary>
            Get the <see cref="T:ICSharpCode.SharpZipLib.Zip.FileUpdateMode" /> to apply during updates.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage">
      <summary>
            An abstract <see cref="T:ICSharpCode.SharpZipLib.Zip.IArchiveStorage" /> suitable for extension by inheritance.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.#ctor(ICSharpCode.SharpZipLib.Zip.FileUpdateMode)">
      <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage" /> class.
            </summary>
      <param name="updateMode">The update mode.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.GetTemporaryOutput">
      <summary>
            Gets a temporary output <see cref="T:System.IO.Stream" /></summary>
      <returns>Returns the temporary output stream.</returns>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.ConvertTemporaryToFinal">
      </seealso>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.ConvertTemporaryToFinal">
      <summary>
            Converts the temporary <see cref="T:System.IO.Stream" /> to its final form.
            </summary>
      <returns>Returns a <see cref="T:System.IO.Stream" /> that can be used to read
            the final storage for the archive.</returns>
      <seealso cref="M:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.GetTemporaryOutput" />
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
      <summary>
            Make a temporary copy of a <see cref="T:System.IO.Stream" />.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to make a copy of.</param>
      <returns>Returns a temporary output <see cref="T:System.IO.Stream" /> that is a copy of the input.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
      <summary>
            Return a stream suitable for performing direct updates on the original source.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to open for direct update.</param>
      <returns>Returns a stream suitable for direct updating.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.Dispose">
      <summary>
            Disposes this instance.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.UpdateMode">
      <summary>
            Gets the update mode applicable.
            </summary>
      <value>The update mode.</value>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage">
      <summary>
            An <see cref="T:ICSharpCode.SharpZipLib.Zip.IArchiveStorage" /> implementation suitable for hard disks.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage.#ctor(ICSharpCode.SharpZipLib.Zip.ZipFile,ICSharpCode.SharpZipLib.Zip.FileUpdateMode)">
      <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage" /> class.
            </summary>
      <param name="file">The file.</param>
      <param name="updateMode">The update mode.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage.#ctor(ICSharpCode.SharpZipLib.Zip.ZipFile)">
      <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage" /> class.
            </summary>
      <param name="file">The file.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage.GetTemporaryOutput">
      <summary>
            Gets a temporary output <see cref="T:System.IO.Stream" /> for performing updates on.
            </summary>
      <returns>Returns the temporary output stream.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage.ConvertTemporaryToFinal">
      <summary>
            Converts a temporary <see cref="T:System.IO.Stream" /> to its final form.
            </summary>
      <returns>Returns a <see cref="T:System.IO.Stream" /> that can be used to read
            the final storage for the archive.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
      <summary>
            Make a temporary copy of a stream.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to copy.</param>
      <returns>Returns a temporary output <see cref="T:System.IO.Stream" /> that is a copy of the input.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
      <summary>
            Return a stream suitable for performing direct updates on the original source.
            </summary>
      <param name="stream">The current stream.</param>
      <returns>Returns a stream suitable for direct updating.</returns>
      <remarks>If the <paramref name="current" /> stream is not null this is used as is.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage.Dispose">
      <summary>
            Disposes this instance.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage">
      <summary>
            An <see cref="T:ICSharpCode.SharpZipLib.Zip.IArchiveStorage" /> implementation suitable for in memory streams.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage" /> class.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.#ctor(ICSharpCode.SharpZipLib.Zip.FileUpdateMode)">
      <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage" /> class.
            </summary>
      <param name="updateMode">The <see cref="T:ICSharpCode.SharpZipLib.Zip.FileUpdateMode" /> to use</param>
      <remarks>This constructor is for testing as memory streams dont really require safe mode.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.GetTemporaryOutput">
      <summary>
            Gets the temporary output <see cref="T:System.IO.Stream" /></summary>
      <returns>Returns the temporary output stream.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.ConvertTemporaryToFinal">
      <summary>
            Converts the temporary <see cref="T:System.IO.Stream" /> to its final form.
            </summary>
      <returns>Returns a <see cref="T:System.IO.Stream" /> that can be used to read
            the final storage for the archive.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
      <summary>
            Make a temporary copy of the original stream.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to copy.</param>
      <returns>Returns a temporary output <see cref="T:System.IO.Stream" /> that is a copy of the input.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
      <summary>
            Return a stream suitable for performing direct updates on the original source.
            </summary>
      <param name="stream">The original source stream</param>
      <returns>Returns a stream suitable for direct updating.</returns>
      <remarks>If the <paramref name="stream" /> passed is not null this is used;
            otherwise a new <see cref="T:System.IO.MemoryStream" /> is returned.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.Dispose">
      <summary>
            Disposes this instance.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.FinalStream">
      <summary>
            Get the stream returned by <see cref="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.ConvertTemporaryToFinal" /> if this was in fact called.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.DescriptorData">
      <summary>
            Holds data pertinent to a data descriptor.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.DescriptorData.CompressedSize">
      <summary>
            Get /set the compressed size of data.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.DescriptorData.Size">
      <summary>
            Get / set the uncompressed size of data
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.DescriptorData.Crc">
      <summary>
            Get /set the crc value.
            </summary>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipInputStream">
      <summary>
             This is an InflaterInputStream that reads the files baseInputStream an zip archive
             one after another.  It has a special method to get the zip entry of
             the next file.  The zip entry contains information about the file name
             size, compressed size, Crc, etc.
             It includes support for Stored and Deflated entries.
             <br /><br />Author of the original java version : Jochen Hoenicke
             </summary>
      <example> This sample shows how to read a zip file
             <code lang="C#">
             using System;
             using System.Text;
             using System.IO;
             
             using ICSharpCode.SharpZipLib.Zip;
             
             class MainClass
             {
             	public static void Main(string[] args)
             	{
             		using ( ZipInputStream s = new ZipInputStream(File.OpenRead(args[0]))) {
            
             			ZipEntry theEntry;
             			const int size = 2048;
             			byte[] data = new byte[2048];
             			
             			while ((theEntry = s.GetNextEntry()) != null) {
                             if ( entry.IsFile ) {
             				    Console.Write("Show contents (y/n) ?");
             				    if (Console.ReadLine() == "y") {
             				    	while (true) {
             				    		size = s.Read(data, 0, data.Length);
             				    		if (size &gt; 0) {
             				    			Console.Write(new ASCIIEncoding().GetString(data, 0, size));
             				    		} else {
             				    			break;
             				    		}
             				    	}
             				    }
             				}
             			}
             		}
             	}
             }
             </code></example>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipInputStream.#ctor(System.IO.Stream)">
      <summary>
            Creates a new Zip input stream, for reading a zip archive.
            </summary>
      <param name="baseInputStream">The underlying <see cref="T:System.IO.Stream" /> providing data.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipInputStream.#ctor(System.IO.Stream,System.Int32)">
      <summary>
            Creates a new Zip input stream, for reading a zip archive.
            </summary>
      <param name="baseInputStream">The underlying <see cref="T:System.IO.Stream" /> providing data.</param>
      <param name="bufferSize">Size of the buffer.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipInputStream.GetNextEntry">
      <summary>
            Advances to the next entry in the archive
            </summary>
      <returns>
            The next <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry">entry</see> in the archive or null if there are no more entries.
            </returns>
      <remarks>
            If the previous entry is still open <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipInputStream.CloseEntry">CloseEntry</see> is called.
            </remarks>
      <exception cref="T:System.InvalidOperationException">
            Input stream is closed
            </exception>
      <exception cref="T:ICSharpCode.SharpZipLib.Zip.ZipException">
            Password is not set, password is invalid, compression method is invalid,
            version required to extract is not supported
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipInputStream.CloseEntry">
      <summary>
            Closes the current zip entry and moves to the next one.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            The stream is closed
            </exception>
      <exception cref="T:ICSharpCode.SharpZipLib.Zip.ZipException">
            The Zip stream ends early
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipInputStream.ReadByte">
      <summary>
            Reads a byte from the current zip entry.
            </summary>
      <returns>
            The byte or -1 if end of stream is reached.
            </returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipInputStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Read a block of bytes from the stream.
            </summary>
      <param name="buffer">The destination for the bytes.</param>
      <param name="offset">The index to start storing data.</param>
      <param name="count">The number of bytes to attempt to read.</param>
      <returns>Returns the number of bytes read.</returns>
      <remarks>Zero bytes read means end of stream.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipInputStream.Close">
      <summary>
            Closes the zip input stream
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipInputStream.Password">
      <summary>
            Optional password used for encryption when non-null
            </summary>
      <value>A password for all encrypted <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry">entries </see> in this <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipInputStream" /></value>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipInputStream.CanDecompressEntry">
      <summary>
            Gets a value indicating if there is a current entry and it can be decompressed
            </summary>
      <remarks>
            The entry can only be decompressed if the library supports the zip features required to extract it.
            See the <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Version">ZipEntry Version</see> property for more details.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipInputStream.Available">
      <summary>
            Returns 1 if there is an entry available
            Otherwise returns 0.
            </summary>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipInputStream.Length">
      <summary>
            Returns the current size that can be read from the current entry if available
            </summary>
      <exception cref="T:ICSharpCode.SharpZipLib.Zip.ZipException">Thrown if the entry size is not known.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if no entry is currently available.</exception>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipNameTransform">
      <summary>
            ZipNameTransform transforms names as per the Zip file naming convention.
            </summary>
      <remarks>The use of absolute names is supported although its use is not valid 
            according to Zip naming conventions, and should not be used if maximum compatability is desired.</remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipNameTransform.#ctor">
      <summary>
            Initialize a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipNameTransform"></see></summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipNameTransform.#ctor(System.String)">
      <summary>
            Initialize a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipNameTransform"></see></summary>
      <param name="trimPrefix">The string to trim from the front of paths if found.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipNameTransform.TransformDirectory(System.String)">
      <summary>
            Transform a windows directory name according to the Zip file naming conventions.
            </summary>
      <param name="name">The directory name to transform.</param>
      <returns>The transformed name.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipNameTransform.TransformFile(System.String)">
      <summary>
            Transform a windows file name according to the Zip file naming conventions.
            </summary>
      <param name="name">The file name to transform.</param>
      <returns>The transformed name.</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipNameTransform.IsValidName(System.String,System.Boolean)">
      <summary>
            Test a name to see if it is a valid name for a zip entry.
            </summary>
      <param name="name">The name to test.</param>
      <param name="relaxed">If true checking is relaxed about windows file names and absolute paths.</param>
      <returns>Returns true if the name is a valid zip name; false otherwise.</returns>
      <remarks>Zip path names are actually in Unix format, and should only contain relative paths.
            This means that any path stored should not contain a drive or
            device letter, or a leading slash.  All slashes should forward slashes '/'.
            An empty name is valid for a file where the input comes from standard input.
            A null name is not considered valid.
            </remarks>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipNameTransform.IsValidName(System.String)">
      <summary>
            Test a name to see if it is a valid name for a zip entry.
            </summary>
      <param name="name">The name to test.</param>
      <returns>Returns true if the name is a valid zip name; false otherwise.</returns>
      <remarks>Zip path names are actually in unix format,
            and should only contain relative paths if a path is present.
            This means that the path stored should not contain a drive or
            device letter, or a leading slash.  All slashes should forward slashes '/'.
            An empty name is valid where the input comes from standard input.
            A null name is not considered valid.
            </remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipNameTransform.TrimPrefix">
      <summary>
            Get/set the path prefix to be trimmed from paths if present.
            </summary>
      <remarks>The prefix is trimmed before any conversion from
            a windows path is done.</remarks>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipOutputStream">
      <summary>
             This is a DeflaterOutputStream that writes the files into a zip
             archive one after another.  It has a special method to start a new
             zip entry.  The zip entries contains information about the file name
             size, compressed size, CRC, etc.
             
             It includes support for Stored and Deflated entries.
             This class is not thread safe.
             <br /><br />Author of the original java version : Jochen Hoenicke
             </summary>
      <example> This sample shows how to create a zip file
             <code>
             using System;
             using System.IO;
             
             using ICSharpCode.SharpZipLib.Core;
             using ICSharpCode.SharpZipLib.Zip;
             
             class MainClass
             {
             	public static void Main(string[] args)
             	{
             		string[] filenames = Directory.GetFiles(args[0]);
             		byte[] buffer = new byte[4096];
             		
             		using ( ZipOutputStream s = new ZipOutputStream(File.Create(args[1])) ) {
             		
             			s.SetLevel(9); // 0 - store only to 9 - means best compression
             		
             			foreach (string file in filenames) {
             				ZipEntry entry = new ZipEntry(file);
             				s.PutNextEntry(entry);
            
             				using (FileStream fs = File.OpenRead(file)) {
            						StreamUtils.Copy(fs, s, buffer);
             				}
             			}
             		}
             	}
             }	
             </code></example>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.#ctor(System.IO.Stream)">
      <summary>
            Creates a new Zip output stream, writing a zip archive.
            </summary>
      <param name="baseOutputStream">
            The output stream to which the archive contents are written.
            </param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.#ctor(System.IO.Stream,System.Int32)">
      <summary>
            Creates a new Zip output stream, writing a zip archive.
            </summary>
      <param name="baseOutputStream">The output stream to which the archive contents are written.</param>
      <param name="bufferSize">Size of the buffer to use.</param>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.SetComment(System.String)">
      <summary>
            Set the zip file comment.
            </summary>
      <param name="comment">
            The comment text for the entire archive.
            </param>
      <exception name="ArgumentOutOfRangeException">
            The converted comment is longer than 0xffff bytes.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.SetLevel(System.Int32)">
      <summary>
            Sets the compression level.  The new level will be activated
            immediately.
            </summary>
      <param name="level">The new compression level (1 to 9).</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            Level specified is not supported.
            </exception>
      <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Deflater" />
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.GetLevel">
      <summary>
            Get the current deflater compression level
            </summary>
      <returns>The current compression level</returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.PutNextEntry(ICSharpCode.SharpZipLib.Zip.ZipEntry)">
      <summary>
            Starts a new Zip entry. It automatically closes the previous
            entry if present.
            All entry elements bar name are optional, but must be correct if present.
            If the compression method is stored and the output is not patchable
            the compression for that entry is automatically changed to deflate level 0
            </summary>
      <param name="entry">
            the entry.
            </param>
      <exception cref="T:System.ArgumentNullException">
            if entry passed is null.
            </exception>
      <exception cref="T:System.IO.IOException">
            if an I/O error occured.
            </exception>
      <exception cref="T:System.InvalidOperationException">
            if stream was finished
            </exception>
      <exception cref="T:ICSharpCode.SharpZipLib.Zip.ZipException">
            Too many entries in the Zip file<br />
            Entry name is too long<br />
            Finish has already been called<br /></exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.CloseEntry">
      <summary>
            Closes the current entry, updating header and footer information as required
            </summary>
      <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
      <exception cref="T:System.InvalidOperationException">
            No entry is active.
            </exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Writes the given buffer to the current entry.
            </summary>
      <param name="buffer">The buffer containing data to write.</param>
      <param name="offset">The offset of the first byte to write.</param>
      <param name="count">The number of bytes to write.</param>
      <exception cref="T:ICSharpCode.SharpZipLib.Zip.ZipException">Archive size is invalid</exception>
      <exception cref="T:System.InvalidOperationException">No entry is active.</exception>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.Finish">
      <summary>
            Finishes the stream.  This will write the central directory at the
            end of the zip file and flush the stream.
            </summary>
      <remarks>
            This is automatically called when the stream is closed.
            </remarks>
      <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
      <exception cref="T:ICSharpCode.SharpZipLib.Zip.ZipException">
            Comment exceeds the maximum length<br />
            Entry name exceeds the maximum length
            </exception>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.IsFinished">
      <summary>
            Gets a flag value of true if the central header has been added for this archive; false if it has not been added.
            </summary>
      <remarks>No further entries can be added once this has been done.</remarks>
    </member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.UseZip64">
      <summary>
            Get / set a value indicating how Zip64 Extension usage is determined when adding entries.
            </summary>
      <remarks>Older archivers may not understand Zip64 extensions.
            If backwards compatability is an issue be careful when adding <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Size">entries</see> to an archive.
            Setting this property to off is workable but less desirable as in those circumstances adding a file
            larger then 4GB will fail.</remarks>
    </member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipTesting">
      <summary>
            Provides support for testing in memory zip archives.
            </summary>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipTesting.TestArchive(System.Byte[])">
      <summary>
            Tests the archive.
            </summary>
      <param name="data">The data.</param>
      <returns>
      </returns>
    </member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipTesting.TestArchive(System.Byte[],System.String)">
      <summary>
            Tests the archive.
            </summary>
      <param name="data">The data.</param>
      <param name="password">The password.</param>
      <returns>true if archive tests ok; false otherwise.</returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.Com.AMap.Maps.Core.Utilities.IsolatedStorageCommon.IsolatedStorageSettingHelper.AddIsolateStorageObj(System.String,System.Object)">
      <summary>
            Add IsolateStorage Setting
            </summary>
      <param name="key">Key</param>
      <param name="value">Value</param>
      <returns>Is Add</returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.Com.AMap.Maps.Core.Utilities.IsolatedStorageCommon.IsolatedStorageSettingHelper.GetIsolateStorageByStr(System.String)">
      <summary>
            Get IsolateStorage Save Value To String Format
            </summary>
      <param name="key">Key</param>
      <returns>String Format</returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.Com.AMap.Maps.Core.Utilities.IsolatedStorageCommon.IsolatedStorageSettingHelper.GetIsolateStorageByObj(System.String)">
      <summary>
            Get IsolateStorage Save Value To Object Format
            </summary>
      <param name="key">Key</param>
      <returns>object Format</returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.Com.AMap.Maps.Core.Utilities.IsolatedStorageCommon.IsolatedStorageSettingHelper.IsolateStorageKeyIsExist(System.String)">
      <summary>
            IsolateStorage Is Exists
            </summary>
      <param name="key">Storage Key</param>
      <returns>Is Exists</returns>
    </member>
    <member name="M:Com.AMap.Api.Maps.Com.AMap.Maps.Core.Utilities.IsolatedStorageCommon.IsolatedStorageSettingHelper.RemoveIsolateStorageByKey(System.String)">
      <summary>
            Remove The IsolateStorage KeyValuePair
            </summary>
      <param name="key">Key</param>
      <returns>Is Remove</returns>
    </member>
    <member name="F:Com.AMap.Maps.Core.SmartDispatcher._instance">
      <summary>
            A single Dispatcher instance to marshall actions to the user
            interface thread.
            </summary>
    </member>
    <member name="F:Com.AMap.Maps.Core.SmartDispatcher._designer">
      <summary>
            Backing field for a value indicating whether this is a design-time
            environment.
            </summary>
    </member>
    <member name="M:Com.AMap.Maps.Core.SmartDispatcher.RequireInstance">
      <summary>
            Requires an instance and attempts to find a Dispatcher if one has
            not yet been set.
            </summary>
    </member>
    <member name="M:Com.AMap.Maps.Core.SmartDispatcher.Initialize">
      <summary>
            Initializes the SmartDispatcher system, attempting to use the
            RootVisual of the plugin to retrieve a Dispatcher instance.
            </summary>
    </member>
    <member name="M:Com.AMap.Maps.Core.SmartDispatcher.Initialize(System.Windows.Threading.Dispatcher)">
      <summary>
            Initializes the SmartDispatcher system with the dispatcher
            instance.
            </summary>
      <param name="dispatcher">The dispatcher instance.</param>
    </member>
    <member name="M:Com.AMap.Maps.Core.SmartDispatcher.CheckAccess">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Maps.Core.SmartDispatcher.BeginInvoke(System.Action)">
      <summary>
            Executes the specified delegate asynchronously on the user interface
            thread. If the current thread is the user interface thread, the
            dispatcher if not used and the operation happens immediately.
            </summary>
      <param name="a">A delegate to a method that takes no arguments and 
            does not return a value, which is either pushed onto the Dispatcher 
            event queue or immediately run, depending on the current thread.</param>
    </member>
    <member name="T:Com.AMap.Maps.Core.Utilities">
      <summary>
            公共类
            </summary>
    </member>
    <member name="M:Com.AMap.Maps.Core.Utilities.HexToColor(System.String)">
      <summary>
            将十六进制字符串换算成颜色，将16为颜色 Color对象 调用方式Utilities.Utilities.HexToColor("#a3b4ff");
            </summary>
      <param name="hexValue">将16为颜色 Color值</param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Maps.Core.Utilities.ColorFromHexString(System.String)">
      <summary>
            字符产类型的颜色值转为Color类型
            </summary>
      <param name="HexColor">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Maps.Core.Utilities.IntersectsBounds(System.Windows.Rect,System.Windows.Rect)">
      <summary>
            判断Rect是否相交
            </summary>
      <param name="bounds1">第一个区域</param>
      <param name="bounds2">第二个区域</param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Maps.Core.Utilities._intersectsBounds(System.Windows.Rect,System.Windows.Rect)">
      <summary>
            比较大的Rect和小Rect之间是否相交
            </summary>
      <param name="bounds">大</param>
      <param name="smallBounds">小</param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Maps.Core.Utilities.computeAngleByPoints(System.Windows.Point,System.Windows.Point)">
      <summary>
            已知两地理坐标点，求两点夹角
            </summary>
      <param name="point1">直线起点经纬度坐标</param>
      <param name="point2">直线终点经纬度坐标</param>
      <returns>两点之间的距离</returns>
    </member>
    <member name="M:Com.AMap.Maps.Core.Utilities.OffSetElement(System.Windows.FrameworkElement)">
      <summary>
            元素偏移量
            </summary>
      <param name="element">
      </param>
    </member>
    <member name="M:Com.AMap.Maps.Core.Utilities.StreamToBytes(System.IO.Stream)">
      <summary> 
            将 Stream 转成 byte[] 
            </summary>
    </member>
    <member name="M:Com.AMap.Maps.Core.Utilities.BytesToStream(System.Byte[])">
      <summary> 
            将 byte[] 转成 Stream 
            </summary>
    </member>
    <member name="M:Com.AMap.Maps.Core.Utilities.IntToByte4uint32(System.Int32)">
      <summary>
            将32位整型数字转成字节
            </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Maps.Core.Utilities.BytesToShort(System.Byte[])">
      <summary>
            将一个长度为2 byte数组转为short值
            </summary>
      <param name="bytesShort">要转的字节数组</param>
      <returns>转后的short值</returns>
    </member>
    <member name="M:Com.AMap.Maps.Core.Utilities.BytesToInt4uint32(System.Byte[])">
      <summary>
            将字节转成32位整型
            </summary>
      <param name="bytes">待转换的字节数组</param>
      <returns>32位整型数据</returns>
    </member>
    <member name="M:Com.AMap.Maps.Core.Utilities.IsValidPoint(System.Double,System.Double)">
      <summary>
            判断当前点是否在中国范围内
            </summary>
      <param name="pointX">
      </param>
      <param name="pointY">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Com.AMap.Maps.Core.Utilities.FilterPoints(System.Collections.Generic.List{Com.AMap.Api.Maps.Model.LatLng})">
      <summary>
            筛选Points
            </summary>
      <param name="latlngs">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Microsoft.Phone.Controls.Theme">
      <summary>
            Represents a light/dark theme.
            </summary>
    </member>
    <member name="T:Microsoft.Phone.Controls.AccentColor">
      <summary>
            Represents an accent color available to users on the Windows Phone. 
            I've also included a few popular themes found on specific phones or in
            specific markets.
            </summary>
    </member>
    <member name="T:Microsoft.Phone.Controls.ThemeManagerOverrideOptions">
      <summary>
            Options for overriding the themes in the application instance with
            regards to system components that do not use the XAML static resource
            values.
            </summary>
    </member>
    <member name="F:Microsoft.Phone.Controls.ThemeManagerOverrideOptions.None">
      <summary>
            No special override options. SystemTray and ApplicationBar 
            instances are unaffected and will not be properly themed.
            </summary>
    </member>
    <member name="F:Microsoft.Phone.Controls.ThemeManagerOverrideOptions.SystemTrayColors">
      <summary>
            Colors system trays appropriately.
            </summary>
    </member>
    <member name="F:Microsoft.Phone.Controls.ThemeManagerOverrideOptions.SystemTrayAndApplicationBars">
      <summary>
            Colors system trays appropriately and also any set ApplicationBar
            instances. Will not theme ApplicationBar instances that are 
            created after the page's Navigated event or that are created and
            not set immediately.
            </summary>
    </member>
    <member name="T:Microsoft.Phone.Controls.ThemeManager">
      <summary>
            A specialized Windows Phone theme management class that can be used to
            override the user's selected Light/Dark operating system for the 
            running app instance. It must be overridden inside the App::App() 
            constructor (or early in initialization) and cannot be changed at 
            runtime or called more than once.
            </summary>
    </member>
    <member name="M:Microsoft.Phone.Controls.ThemeManager.MatchOverriddenTheme(Microsoft.Phone.Shell.IApplicationBar)">
      <summary>
            An extension method for ApplicationBars, will apply the overridden
            theme's coloring to the app bar if needed.
            </summary>
      <param name="bar">The application bar instance.</param>
    </member>
    <member name="M:Microsoft.Phone.Controls.ThemeManager.CreateApplicationBar">
      <summary>
            Creates a new instance of ApplicationBar and applies any 
            overridden theme coloring to the instance.
            </summary>
      <returns>Returns a new ApplicationBar instance with its foreground
            and background colors set.</returns>
    </member>
    <member name="M:Microsoft.Phone.Controls.ThemeManager.OverrideTheme(Microsoft.Phone.Controls.Theme)">
      <summary>
            Overrides the theme resources used at runtime for this instance.
            Will not make any changes to the style resources if the requested
            theme is the same as the runtime theme at startup.
            </summary>
      <param name="theme">The preferred Theme to override to.</param>
    </member>
    <member name="M:Microsoft.Phone.Controls.ThemeManager.InvertTheme">
      <summary>
            Overrides the theme resources used at runtime to be the inverse of
            the user's current operating system theme setting.
            </summary>
    </member>
    <member name="M:Microsoft.Phone.Controls.ThemeManager.ToLightTheme">
      <summary>
            Overrides the theme resources used at runtime to be the Light 
            theme.
            </summary>
    </member>
    <member name="M:Microsoft.Phone.Controls.ThemeManager.ToDarkTheme">
      <summary>
            Overrides the theme resources used at runtime to be the Dark theme.
            </summary>
    </member>
    <member name="M:Microsoft.Phone.Controls.ThemeManager.SetAccentColor(System.UInt32)">
      <summary>
            Overrides the accent color and brush used at runtime to a new one.
            </summary>
      <param name="color">A uint representing the color to set the brush
            and color to.</param>
    </member>
    <member name="M:Microsoft.Phone.Controls.ThemeManager.SetAccentColor(System.Windows.Media.Color)">
      <summary>
            Overrides the accent color and brush used at runtime to a new one.
            </summary>
      <param name="color">A Color to set the accent brush/color to.</param>
    </member>
    <member name="M:Microsoft.Phone.Controls.ThemeManager.SetAccentColor(Microsoft.Phone.Controls.AccentColor)">
      <summary>
            Overrides the accent color and brush used at runtime to a new one.
            </summary>
      <param name="accentColor">Represents the new popular accent color
            to use.</param>
    </member>
    <member name="M:Microsoft.Phone.Controls.ThemeManager.SetCustomTheme(System.Uri,Microsoft.Phone.Controls.Theme)">
      <summary>
            Uses a custom theme file.
            </summary>
      <param name="styleUri">Uri to the style.</param>
      <param name="themeToOverride">The theme name/value to override.</param>
    </member>
    <member name="M:Microsoft.Phone.Controls.ThemeManager.SetCustomTheme(System.Windows.ResourceDictionary,Microsoft.Phone.Controls.Theme)">
      <summary>
            Uses a custom theme resource dictionary.
            </summary>
      <param name="rd">The resource dictionary instance.</param>
      <param name="themeToOverride">The theme value to override.</param>
    </member>
    <member name="P:Microsoft.Phone.Controls.ThemeManager.OverrideOptions">
      <summary>
            Gets or sets a value indicating whether to hook up to navigation
            events to update system tray background and foreground colors with
            the overriden values.
            </summary>
    </member>
  </members>
</doc>